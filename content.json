{"meta":{"title":"地球人你好","subtitle":"","description":"","author":"Xieyuw","url":"http://yoursite.com","root":"/"},"pages":[{"title":"reading","date":"2020-01-15T13:18:39.000Z","updated":"2020-01-15T13:18:39.215Z","comments":true,"path":"reading/index.html","permalink":"http://yoursite.com/reading/index.html","excerpt":"","text":""},{"title":"个人简介","date":"2020-01-19T07:27:00.000Z","updated":"2020-01-27T05:05:44.863Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"WELCOME TO MY BLOG#关于我00后本科生在读没脾气但有底线喜欢一切新鲜事物愿意不断努力尝试#兴趣爱好骑行(有过骑行环游中国/世界的想法)徒步(想用眼睛去感受这个世界)做饭(我太懒了)竞赛(算法竞赛、数学竞赛)编程(敲代码真的是一件很快乐的事情)学习(永远保持对世界的好奇心,活到老学到老)#联系方式QQ: 948011378WeChat: HeyWwoWeiBo: NocompanyZhiHu: OideaCodeforce: ?"}],"posts":[{"title":"VJudge--Rightmost Digit","slug":"Rightmost Digit","date":"2020-06-29T16:00:00.000Z","updated":"2020-06-30T03:00:56.952Z","comments":true,"path":"2020/06/30/Rightmost Digit/","link":"","permalink":"http://yoursite.com/2020/06/30/Rightmost%20Digit/","excerpt":"","text":"题目 - Rightmost DigitGiven a positive integer N, you should output the most right digit of N^N. Input The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.Each test case contains a single positive integer N(1&lt;=N&lt;=1,000,000,000). Output For each test case, you should output the rightmost digit of N^N. Sample Input 123234 Sample Output 1276 Hint 12In the first case, 3 * 3 * 3 = 27, so the rightmost digit is 7.In the second case, 4 * 4 * 4 * 4 = 256, so the rightmost digit is 6. 题目大意:求n的平方最右边的数字。 思路：需要用到快速幂以及取模。 AC代码：12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int fastPow(int a, int n) &#123; int base = a % 10; int res = 1; while(n) &#123; if(n &amp; 1) res = res * base % 10; base = base * base % 10; n &gt;&gt;= 1; &#125; return res;&#125;int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; int n; cin &gt;&gt; n; cout &lt;&lt; fastPow(n, n) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"快速幂","slug":"快速幂","permalink":"http://yoursite.com/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"VJudge--A sequence of numbers","slug":"A sequence of numbers","date":"2020-06-28T16:00:00.000Z","updated":"2020-06-29T00:59:00.158Z","comments":true,"path":"2020/06/29/A sequence of numbers/","link":"","permalink":"http://yoursite.com/2020/06/29/A%20sequence%20of%20numbers/","excerpt":"","text":"题目 - A sequence of numbersXinlv wrote some sequences on the paper a long time ago, they might be arithmetic or geometric sequences. The numbers are not very clear now, and only the first three numbers of each sequence are recognizable. Xinlv wants to know some numbers in these sequences, and he needs your help. Input The first line contains an integer N, indicting that there are N sequences. Each of the following N lines contain four integers. The first three indicating the first three numbers of the sequence, and the last one is K, indicating that we want to know the K-th numbers of the sequence. You can assume 0 &lt; K &lt;= 10^9, and the other three numbers are in the range [0, 2^63). All the numbers of the sequences are integers. And the sequences are non-decreasing. Output Output one line for each test case, that is, the K-th number module (%) 200907. Sample Input 12321 2 3 51 2 4 5 Sample Output 12516 题目大意:现在有一个由整数组成的序列，可能是等差数列，也可能是等比数列，但是只给出前3个数，要求你求数列中第k个数% 200907的结果。所给数列是一个非递减数列。 输入：首先是一个t表示输入的实例个数，以下t行每行代表一个实例。每行包括4个整数，前3个整数在[0, 2^63)范围内，表示数列的头3个数，第4个数是k表示要求的数列中的第k个数。其中0 &lt; k &lt;= 10^9。 输出：输出数列中第k个数%200907的结果。 思路：需要用到快速幂算法，注意一下使用long long型。 AC代码：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;const int N = 200907;typedef long long ll;ll fun(ll a, ll b, ll k) &#123; ll base = b / a; ll res = 1; while(k) &#123; if(k &amp; 1) res = (res * base) % N; base = (base * base) % N; k &gt;&gt;= 1; &#125; return res;&#125;int main() &#123; ll a, b, c, k, res; int t; scanf(\"%d\", &amp;t); for(int i = 0; i &lt; t; ++i) &#123; scanf(\"%I64d%I64d%I64d%I64d\", &amp;a, &amp;b, &amp;c, &amp;k); if(a + c == 2 * b) res = (a+(k - 1)*(b - a)) % N; else res = a * fun(a, b, k - 1) % N; printf(\"%I64d\\n\", res); &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"快速幂","slug":"快速幂","permalink":"http://yoursite.com/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"LeetCode--回文数","slug":"LeetCode--回文数","date":"2020-04-11T16:00:00.000Z","updated":"2020-04-12T01:28:34.288Z","comments":true,"path":"2020/04/12/LeetCode--回文数/","link":"","permalink":"http://yoursite.com/2020/04/12/LeetCode--%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"","text":"[9]:回文数题目：https://leetcode-cn.com/problems/two-sum/description/ 解题：我是把整数转化为字符串做的。 如果用整数的话，可能会有溢出，只翻转一半的数字。 还是得不断学习鸭。 代码:123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || x != 0 &amp;&amp; x % 10 == 0) return false; int revertedNumber = 0; while(x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; return x == revertedNumber || x == revertedNumber / 10; &#125;&#125;;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"LeetCode--整数反转","slug":"LeetCode--整数反转","date":"2020-04-10T16:00:00.000Z","updated":"2020-04-11T14:24:27.055Z","comments":true,"path":"2020/04/11/LeetCode--整数反转/","link":"","permalink":"http://yoursite.com/2020/04/11/LeetCode--%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"[7]:整数反转题目：https://leetcode-cn.com/problems/reverse-integer/description/ 解题：看别人的代码不得不感慨！ 太强了！！ 代码:123456789101112class Solution &#123;public: int reverse(int x) &#123; long ans = 0; while(x) &#123; ans = ans * 10 + x % 10; x /= 10; &#125; return ans &gt; 2147483647 || ans&lt;-2147483648? 0:ans; &#125;&#125;;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"LeetCode--两数之和","slug":"LeetCode--两数之和","date":"2020-04-08T16:00:00.000Z","updated":"2020-04-09T05:03:15.097Z","comments":true,"path":"2020/04/09/LeetCode--两数之和/","link":"","permalink":"http://yoursite.com/2020/04/09/LeetCode--%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"[1]:两数之和题目：https://leetcode-cn.com/problems/two-sum/description/ 解题：直接暴力过的，看了题解之后发现可以用哈希表。 一次哈希速度是最快的。 代码1:123456789101112//暴力class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt;a; for(int i = 0; i &lt; nums.size(); ++i) for(int j = 0; j &lt; nums.size(); ++j) if(nums[i] + nums[j] == target &amp;&amp; i != j) a = &#123;i, j&#125;; return a; &#125;&#125;; 代码2：123456789101112131415//一次哈希class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map &lt;int, int&gt; m; for(int i = 0; i &lt; nums.size(); ++i) &#123; int t = target - nums[i]; if(m.find(t) != m.end()) return &#123;m[t], i&#125;; else m[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;; 代码3：123456789101112131415//两次哈希class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map &lt;int, int&gt; m; for(int i = 0; i &lt; nums.size(); i++) &#123; m[nums[i]] = i; &#125; for(int i = 0 ; i &lt; nums.size(); i++) &#123; if(m.find(target - nums[i]) != m.end() &amp;&amp; m[target - nums[i]] != i) return &#123;i, m[target - nums[i]]&#125;; &#125; return &#123;0&#125;; &#125;&#125;;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"hash-table","slug":"hash-table","permalink":"http://yoursite.com/tags/hash-table/"}]},{"title":"LeetCode--两数之和","slug":"LeetCode--滑动窗口最大值","date":"2020-04-08T16:00:00.000Z","updated":"2020-04-09T05:03:15.097Z","comments":true,"path":"2020/04/09/LeetCode--滑动窗口最大值/","link":"","permalink":"http://yoursite.com/2020/04/09/LeetCode--%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/","excerpt":"","text":"[1]:两数之和题目：https://leetcode-cn.com/problems/two-sum/description/ 解题：直接暴力过的，看了题解之后发现可以用哈希表。 一次哈希速度是最快的。 代码1:123456789101112//暴力class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt;a; for(int i = 0; i &lt; nums.size(); ++i) for(int j = 0; j &lt; nums.size(); ++j) if(nums[i] + nums[j] == target &amp;&amp; i != j) a = &#123;i, j&#125;; return a; &#125;&#125;; 代码2：123456789101112131415//一次哈希class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map &lt;int, int&gt; m; for(int i = 0; i &lt; nums.size(); ++i) &#123; int t = target - nums[i]; if(m.find(t) != m.end()) return &#123;m[t], i&#125;; else m[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;; 代码3：123456789101112131415//两次哈希class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map &lt;int, int&gt; m; for(int i = 0; i &lt; nums.size(); i++) &#123; m[nums[i]] = i; &#125; for(int i = 0 ; i &lt; nums.size(); i++) &#123; if(m.find(target - nums[i]) != m.end() &amp;&amp; m[target - nums[i]] != i) return &#123;i, m[target - nums[i]]&#125;; &#125; return &#123;0&#125;; &#125;&#125;;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"hash-table","slug":"hash-table","permalink":"http://yoursite.com/tags/hash-table/"}]},{"title":"C++中substr函数用法","slug":"C++substr函数","date":"2020-03-26T16:00:00.000Z","updated":"2020-03-28T08:30:49.752Z","comments":true,"path":"2020/03/27/C++substr函数/","link":"","permalink":"http://yoursite.com/2020/03/27/C++substr%E5%87%BD%E6%95%B0/","excerpt":"","text":"话不多说直接上模板：substr(start, length),length可填可不填，start必填即返回一个从指定位置开始并具有指定长度的子字符串，字符串中第一个字符的索引为0.123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str = \"hello, world\"; string str1 = str.substr(0,5); cout &lt;&lt; str1 &lt;&lt; endl; return 0;&#125; 结果为hello.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"学习笔记","slug":"学习笔记-算法","date":"2020-03-14T16:00:00.000Z","updated":"2020-03-15T03:29:31.594Z","comments":true,"path":"2020/03/15/学习笔记-算法/","link":"","permalink":"http://yoursite.com/2020/03/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/","excerpt":"","text":"学习笔记-算法主要是方便我以后复习，以下内容可能有些不严谨。一、辗转相除法（欧几里德定理）​ 用来求最大公约是和最小公倍数 gcd = (b, a % b) lcm = a * b / gcd​ 例如：a b c(a % b) ​ 65 15 5 ​ 15 5 0 ​ 所以最大公约数为5 伪代码：1234567891011121314if(a &lt; b) &#123; t = a; a = b; b = t;&#125;d = a * b;c = a % b;while(c != 0) &#123; a = b; b = c; c = a % b;&#125;cout&lt;&lt;\"最大公约数:\"&lt;&lt;b&lt;&lt;endl;cout&lt;&lt;\"最小公倍数:\"&lt;&lt;d / b&lt;&lt;endl; 二、并查集一开始我想的是DFS，但是DFS一直没学会呜呜呜，这个题很像染色定理，然后看了讲解发现这个题还可以用并查集做（明明学过并查集为什么我没想到呢）。 三、DFS当时第一反应是并查集，写完之后不对，又读了一遍题目，题目要求是认识的人不能在一个考场，如果用并查集解决的话应该是认识的人在一个考场，最后发现是用DFS。","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"shadowsocks翻墙教程","slug":"shadowsocks","date":"2020-03-06T16:00:00.000Z","updated":"2020-03-07T00:29:00.737Z","comments":true,"path":"2020/03/07/shadowsocks/","link":"","permalink":"http://yoursite.com/2020/03/07/shadowsocks/","excerpt":"","text":"shadowsocks翻墙教程这是我是参考翻墙教程，分享一下。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"翻墙","slug":"翻墙","permalink":"http://yoursite.com/tags/%E7%BF%BB%E5%A2%99/"}]},{"title":"NOI--放苹果","slug":"NOI--放苹果","date":"2020-02-18T16:00:00.000Z","updated":"2020-02-19T12:54:02.805Z","comments":true,"path":"2020/02/19/NOI--放苹果/","link":"","permalink":"http://yoursite.com/2020/02/19/NOI--%E6%94%BE%E8%8B%B9%E6%9E%9C/","excerpt":"","text":"27:单词翻转题目:放苹果描述 把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。 输入 第一行是测试数据的数目t（0 &lt;= t &lt;= 20）。以下每行均包含二个整数M和N，以空格分开。1&lt;=M，N&lt;=10。 输出 对输入的每组数据M和N，用一行输出相应的K。 样例输入 1217 3 样例输出 18 解题:m个苹果放在n个盘中里，分类讨论： 1、如果m &lt; n ,至少会有n-m个盘子是空的，所以忽略这些盘子，f(m, n) = f(m, m) 2、如果m &gt;= n,因为有的盘子为空有的不为空，所以总分法 = 有空盘子 + 无空盘子，有空盘子时，至少有一个空盘子所以等于f(m,n-1),没有空盘子时候，至少每个盘子里都会放一个苹果还剩m-n个苹果放在n个盘子里f(m-n,n). AC代码:1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int f(int x, int y) &#123; if(x == 0) return 1; if(y == 0) return 0; if(x &lt; y) return f(x, x); if(x &gt;= y) return f(x, y - 1) + f(x - y, y);&#125;int main() &#123; int t, m, n; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m&gt;&gt;n; int ans = f(m, n); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/%E9%80%92%E5%BD%92/"}]},{"title":"NOI--拯救行动","slug":"NOI--拯救行动","date":"2020-02-14T16:00:00.000Z","updated":"2020-02-15T12:10:36.173Z","comments":true,"path":"2020/02/15/NOI--拯救行动/","link":"","permalink":"http://yoursite.com/2020/02/15/NOI--%E6%8B%AF%E6%95%91%E8%A1%8C%E5%8A%A8/","excerpt":"","text":"题目–拯救行动描述 公主被恶人抓走，被关押在牢房的某个地方。牢房用N*M (N, M &lt;= 200)的矩阵来表示。矩阵中的每项可以代表道路（@）、墙壁（#）、和守卫（x）。英勇的骑士（r）决定孤身一人去拯救公主（a）。我们假设拯救成功的表示是“骑士到达了公主所在的位置”。由于在通往公主所在位置的道路中可能遇到守卫，骑士一旦遇到守卫，必须杀死守卫才能继续前进。现假设骑士可以向上、下、左、右四个方向移动，每移动一个位置需要1个单位时间，杀死一个守卫需要花费额外的1个单位时间。同时假设骑士足够强壮，有能力杀死所有的守卫。 给定牢房矩阵，公主、骑士和守卫在矩阵中的位置，请你计算拯救行动成功需要花费最短时间。 输入 第一行为一个整数S，表示输入的数据的组数（多组输入）随后有S组数据，每组数据按如下格式输入1、两个整数代表N和M, (N, M &lt;= 200).2、随后N行，每行有M个字符。”@”代表道路，”a”代表公主，”r”代表骑士，”x”代表守卫, “#”代表墙壁。 输出 如果拯救行动成功，输出一个整数，表示行动的最短时间。如果不可能成功，输出”Impossible” 样例输入 123456789101112131415161718192021222327 8#@#####@#@a#@@r@#@@#x@@@@@#@@#@##@@@##@@@#@@@@@@@@@@@@@@ 13 40@x@@##x@#x@x#xxxx##@#x@x@@#x#@#x#@@x@#@xxx###x@x#@@##xx@@@#@x@@#x@xxx@@#x@#x@@x@#@x#@x#x#@@##@@x#@xx#xxx@@x##@@@#@x@@x@x@##x@@@x#xx#@@#xxxx#@@x@x@#@x@@@x@#@#x@#@#xxxxx##@@x##x@xxx@@#x@x####@@@x#x##@#@#xxx#@#x##xxxx@@#xx@@@x@xxx#@#xxx@x######x@xxxx#@x@@@@##@x#xx#xxx@#xx#@#####x#@xxx##@#@x##x##x#@x#@a#xx@##@#@##xx@#@@x@xx#x#@x@#x#@##@xrx@x#xxxx@##x##xx#@#x@xx@#x@@#@###x##x@x#@@#@@x@x@@xx@@@@##@@x@@xx#xx@x###@xxx#@#x#@@###@#@##@x#@x@#@@#@@#@#x@x#x#x###@x@@xxx####x@x##@x####xx#@x#x#@x#x######@@#x@#xxxx#xx@@@#xx#x#####@ 样例输出 12137 题意：​ 之前是用单纯的BFS，遇到x时step+2，遇到@时step+1，这样做不行然后我看了别人的博客，因为这样做求得的只是最短路的时间而不是最短时间，说明我对BFS理解还不是很深刻，所以这就不是一道常规的BFS题目了，有两种解题方式，一种是把x的两秒当成走两步，另一种是用BFS+优先队列。 AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;char maze[205][205];int vis[205][205];int dir[4][2] = &#123;-1, 0, 0, -1, 1, 0, 0, 1&#125;;struct node &#123; int x, y, step; bool operator &lt; (const node &amp;a) const &#123; return step &gt; a.step; &#125;&#125;;int n, m;int flag;node st, ne;int BFS() &#123; priority_queue &lt; node &gt; q; q.push(st); while(!q.empty()) &#123; st = q.top(); q.pop(); for(int i = 0; i &lt; 4; i++) &#123; ne.x = st.x + dir[i][0]; ne.y = st.y + dir[i][1]; if(ne.x &gt;= 1 &amp;&amp; ne.x &lt;= n &amp;&amp; ne.y &gt;= 1 &amp;&amp; ne.y &lt;=m &amp;&amp; !vis[ne.x][ne.y]) &#123; if(maze[ne.x][ne.y] == '@') &#123; ne.step = st.step + 1; q.push(ne); vis[ne.x][ne.y] = 1; &#125; else if(maze[ne.x][ne.y] == 'x') &#123; ne.step = st.step + 2; q.push(ne); vis[ne.x][ne.y] = 1; &#125; else if(maze[ne.x][ne.y] == 'a') &#123; flag = 1; return st.step + 1; &#125; else if(maze[ne.x][ne.y] == '#') &#123; vis[ne.x][ne.y] = 1; &#125; &#125; &#125; &#125;&#125;int main() &#123; int s; cin&gt;&gt;s; while(s--) &#123; memset(vis, 0, sizeof(vis)); flag = 0; cin&gt;&gt;n&gt;&gt;m; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; cin&gt;&gt;maze[i][j]; if(maze[i][j] == 'r') &#123; st.x = i; st.y = j; st.step = 0; vis[st.x][st.y] = 1; &#125; &#125; &#125; int ans = BFS(); if(flag) cout&lt;&lt;ans&lt;&lt;endl; else cout&lt;&lt;\"Impossible\"&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"广搜","slug":"广搜","permalink":"http://yoursite.com/tags/%E5%B9%BF%E6%90%9C/"}]},{"title":"NOI--鸣人和佐助","slug":"NOI--鸣人和佐助","date":"2020-02-14T16:00:00.000Z","updated":"2020-02-15T07:57:11.799Z","comments":true,"path":"2020/02/15/NOI--鸣人和佐助/","link":"","permalink":"http://yoursite.com/2020/02/15/NOI--%E9%B8%A3%E4%BA%BA%E5%92%8C%E4%BD%90%E5%8A%A9/","excerpt":"","text":"27:鸣人和佐助描述 佐助被大蛇丸诱骗走了，鸣人在多少时间内能追上他呢？ 已知一张地图（以二维矩阵的形式表示）以及佐助和鸣人的位置。地图上的每个位置都可以走到，只不过有些位置上有大蛇丸的手下，需要先打败大蛇丸的手下才能到这些位置。鸣人有一定数量的查克拉，每一个单位的查克拉可以打败一个大蛇丸的手下。假设鸣人可以往上下左右四个方向移动，每移动一个距离需要花费1个单位时间，打败大蛇丸的手下不需要时间。如果鸣人查克拉消耗完了，则只可以走到没有大蛇丸手下的位置，不可以再移动到有大蛇丸手下的位置。佐助在此期间不移动，大蛇丸的手下也不移动。请问，鸣人要追上佐助最少需要花费多少时间？ 输入 输入的第一行包含三个整数：M，N，T。代表M行N列的地图和鸣人初始的查克拉数量T。0 &lt; M,N &lt; 200，0 ≤ T &lt; 10后面是M行N列的地图，其中@代表鸣人，+代表佐助。*代表通路，#代表大蛇丸的手下。 输出 输出包含一个整数R，代表鸣人追上佐助最少需要花费的时间。如果鸣人无法追上佐助，则输出-1。 样例输入 12345678910111213样例输入14 4 1#@##**#####+****样例输入24 4 2#@##**#####+**** 样例输出 12345样例输出16样例输出24 解题：之前是准备用二维数组来标记，但是这样的话不行，如果测试样例是这样的话: 12343 6 1@#**** *#*###***##+ 输出结果为-1,实际上正确结果应该是11。所以在标记数组上还要加一个查克拉的数量状态。 AC代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;int m, n, t;char maze[210][210];int vis[210][210][15] = &#123;0&#125;;struct node &#123; int x, y, t, step;&#125;;int flag;node st, en, ne;int dir[4][2] = &#123;-1, 0, 0, 1, 1, 0, 0, -1&#125;;int BFS() &#123; queue&lt;node&gt;q; q.push(st); while(!q.empty()) &#123; st = q.front(); q.pop(); if(st.x == en.x &amp;&amp; st.y == en.y) &#123; flag = 1; return st.step; &#125; for(int i = 0; i &lt; 4; i++) &#123; ne.x = st.x + dir[i][0]; ne.y = st.y + dir[i][1]; if(ne.x &gt;= 1 &amp;&amp; ne.x &lt;= m &amp;&amp; ne.y &gt;= 1 &amp;&amp; ne.y &lt;= n) &#123; if(maze[ne.x][ne.y] == '#' &amp;&amp; st.t &gt;= 1 &amp;&amp; !vis[ne.x][ne.y][st.t-1]) &#123; ne.t = st.t - 1; ne.step = st.step + 1; q.push(ne); vis[ne.x][ne.y][ne.t] = 1; &#125; else if(maze[ne.x][ne.y] != '#' &amp;&amp; !vis[ne.x][ne.y][st.t]) &#123; ne.t = st.t; ne.step = st.step + 1; q.push(ne); vis[ne.x][ne.y][ne.t] = 1; &#125; &#125; &#125; &#125;&#125;int main() &#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;t; flag = 0; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; cin&gt;&gt;maze[i][j]; if(maze[i][j] == '@') &#123; st.x = i; st.y = j; st.t = t; st.step = 0; vis[st.x][st.y][t] = 1; &#125; else if(maze[i][j] == '+') &#123; en.x = i; en.y = j; &#125; &#125; &#125; int ans = BFS(); if(flag) cout&lt;&lt;ans&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"广搜","slug":"广搜","permalink":"http://yoursite.com/tags/%E5%B9%BF%E6%90%9C/"}]},{"title":"NOI--抓住那头牛","slug":"NOI--抓住那头牛","date":"2020-02-13T16:00:00.000Z","updated":"2020-02-14T08:49:39.106Z","comments":true,"path":"2020/02/14/NOI--抓住那头牛/","link":"","permalink":"http://yoursite.com/2020/02/14/NOI--%E6%8A%93%E4%BD%8F%E9%82%A3%E5%A4%B4%E7%89%9B/","excerpt":"","text":"27:抓住那头牛描述 农夫知道一头牛的位置，想要抓住它。农夫和牛都位于数轴上，农夫起始位于点N(0&lt;=N&lt;=100000)，牛位于点K(0&lt;=K&lt;=100000)。农夫有两种移动方式： 1、从X移动到X-1或X+1，每次移动花费一分钟 2、从X移动到2*X，每次移动花费一分钟 假设牛没有意识到农夫的行动，站在原地不动。农夫最少要花多少时间才能抓住牛？ 输入 两个整数，N和K 输出 一个整数，农夫抓到牛所要花费的最小分钟数 样例输入 15 17 样例输出 14 解题：​ 虽然是道很简单的搜索题，但坑点很多 ​ 1.判断牛在人的左边还是右边 ​ 2.数组开大一点 ​ 3.判断是否越界 ​ 否则会一直RE AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int x, t;&#125;;//之前开的1e5 + 10,很神奇，反正是不行int vis[1000010];node st, ne, en;int BFS() &#123; queue &lt;node&gt; q; q.push(st); while(!q.empty()) &#123; st = q.front(); q.pop(); if(st.x == en.x) return st.t; ne.x = st.x + 1; //要判断点是否在范围内 if(ne.x &gt;= 0 &amp;&amp; !vis[ne.x] &amp;&amp; ne.x &lt;= 100000) &#123; ne.t = st.t + 1; q.push(ne); vis[ne.x] = 1; &#125; ne.x = st.x - 1; if(ne.x &gt;= 0 &amp;&amp; !vis[ne.x] &amp;&amp; ne.x &lt;= 100000) &#123; ne.t = st.t + 1; q.push(ne); vis[ne.x] = 1; &#125; ne.x = st.x * 2; if(ne.x &gt;= 0 &amp;&amp; !vis[ne.x] &amp;&amp; ne.x &lt;= 100000) &#123; ne.t = st.t + 1; q.push(ne); vis[ne.x] = 1; &#125;&#125;&#125;int main() &#123; int n, k; cin&gt;&gt;n&gt;&gt;k; //这里也要注意 if(n &gt;= k) &#123; cout&lt;&lt;n-k&lt;&lt;endl; return 0; &#125; st.x = n; st.t = 0; en.x = k; vis[st.x] = 1; cout&lt;&lt;BFS()&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"广搜","slug":"广搜","permalink":"http://yoursite.com/tags/%E5%B9%BF%E6%90%9C/"}]},{"title":"VJudge--Billboard","slug":"VJudge--Billboard","date":"2020-02-10T16:00:00.000Z","updated":"2020-02-11T10:16:40.283Z","comments":true,"path":"2020/02/11/VJudge--Billboard/","link":"","permalink":"http://yoursite.com/2020/02/11/VJudge--Billboard/","excerpt":"","text":"题目 - BillboardAt the entrance to the university, there is a huge rectangular billboard of size h*w (h is its height and w is its width). The board is the place where all possible announcements are posted: nearest programming competitions, changes in the dining room menu, and other important information. On September 1, the billboard was empty. One by one, the announcements started being put on the billboard. Each announcement is a stripe of paper of unit height. More specifically, the i-th announcement is a rectangle of size 1 * wi. When someone puts a new announcement on the billboard, she would always choose the topmost possible position for the announcement. Among all possible topmost positions she would always choose the leftmost one. If there is no valid location for a new announcement, it is not put on the billboard (that’s why some programming contests have no participants from this university). Given the sizes of the billboard and the announcements, your task is to find the numbers of rows in which the announcements are placed. Input There are multiple cases (no more than 40 cases). The first line of the input file contains three integer numbers, h, w, and n (1 &lt;= h,w &lt;= 10^9; 1 &lt;= n &lt;= 200,000) - the dimensions of the billboard and the number of announcements. Each of the next n lines contains an integer number wi (1 &lt;= wi &lt;= 10^9) - the width of i-th announcement. Output For each announcement (in the order they are given in the input file) output one number - the number of the row in which this announcement is placed. Rows are numbered from 1 to h, starting with the top row. If an announcement can’t be put on the billboard, output “-1” for this announcement. Sample Input 1234563 5 524333 Sample Output 123451213-1 题意：​ 第一行输入的前两个数是给的布告栏的高和宽，第三个数是有几个通知，每个通知的的高都是单位长度，下面几行是每个通知的宽要求输出每个通知分别贴在第几行。优先选择最上边和最左边的地方贴。 解题：​ 其实一开始是没有想到用线段树来解题，因为感觉没办法用线段树？我的常规思路是把宽度来当成一个区间，实际上这个题目是把高度当区间来建树，感觉还是挺有收获的，写出来之后一直RE，最后发现我把l，r写成了r,l。这种手误情况还是要尽量避免哇。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 200010;int h, w;int tree[MAXN &lt;&lt; 2];void push_up(int u) &#123; tree[u] = max(tree[u &lt;&lt; 1], tree[u &lt;&lt; 1 | 1]);&#125;void BuildTree(int l, int r, int u) &#123; if(l == r) &#123; tree[u] = w; return; &#125; int mid = (l + r) &gt;&gt; 1; BuildTree(l, mid, u &lt;&lt; 1); BuildTree(mid + 1, r, u &lt;&lt; 1 | 1); push_up(u);&#125;void Update(int x, int l, int r, int u, int ans) &#123; if( l == r) &#123; tree[u] -= x; return; &#125; int mid = (l + r) &gt;&gt; 1; if(ans &lt;= mid) Update(x, l, mid, u &lt;&lt; 1, ans); else Update(x, mid + 1, r, u &lt;&lt; 1 | 1, ans); push_up(u);&#125;int Query(int x, int l, int r, int u) &#123; if(l == r) return l; int mid = (l + r) &gt;&gt; 1; int ans = 0; if(tree[u &lt;&lt; 1] &gt;= x) ans = Query(x, l, mid, u &lt;&lt; 1); else if (tree[u &lt;&lt; 1 | 1] &gt;= x) ans = Query(x, mid + 1, r, u &lt;&lt; 1 | 1); return ans;&#125;int main() &#123; int n; while(~scanf(\"%d%d%d\", &amp;h, &amp;w, &amp;n)) &#123; if(h &gt; n) h = n; BuildTree(1, h, 1); for(int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\", &amp;x); if(tree[1] &lt; x) &#123; printf(\"-1\\n\"); continue; &#125; int ans = Query(x, 1, h, 1); printf(\"%d\\n\", ans); Update(x, 1, h, 1, ans); &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"VJudge--I Hate It","slug":"VJudge--I Hate It","date":"2020-02-10T16:00:00.000Z","updated":"2020-02-11T05:29:25.766Z","comments":true,"path":"2020/02/11/VJudge--I Hate It/","link":"","permalink":"http://yoursite.com/2020/02/11/VJudge--I%20Hate%20It/","excerpt":"","text":"题目 - I Hate It很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output 对于每一次询问操作，在一行里面输出最高成绩。 Sample Input 123456785 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5 Sample Output 12345659 Hint 1Huge input,the C function scanf() will work better than cin 题意：​ 线段树的基本操作。 解题：​ TLE，然后我加了个algorithm头文件就AC了，迷惑行为？？ AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 200005;int tree[MAXN &lt;&lt; 2];void BuildTree(int l, int r, int u) &#123; if(l == r) &#123; scanf(\"%d\", &amp;tree[u]); return; &#125; int mid = (l + r) &gt;&gt; 1; BuildTree(l, mid, u &lt;&lt; 1); BuildTree(mid + 1, r, u &lt;&lt; 1 | 1); tree[u] = max(tree[u &lt;&lt; 1], tree[u &lt;&lt; 1 | 1]);&#125;int Query(int a, int b, int l, int r, int u) &#123; if(a &lt;= l &amp;&amp; b &gt;= r) return tree[u]; int mid = (l + r) &gt;&gt; 1; int ans = 0; if(a &lt;= mid) ans = max(ans, Query(a, b, l, mid, u &lt;&lt; 1)); if(b &gt; mid) ans = max(ans, Query(a, b, mid + 1, r, u &lt;&lt; 1 | 1)); return ans;&#125;void Update(int a, int b, int l, int r, int u) &#123; if(l == a &amp;&amp; r == a) &#123; tree[u] = b; return; &#125; int mid = (l + r) &gt;&gt; 1; if(a &lt;= mid) Update(a, b, l, mid, u &lt;&lt; 1); else Update(a, b, mid + 1, r, u &lt;&lt; 1 | 1); tree[u] = max(tree[u &lt;&lt; 1], tree[u &lt;&lt; 1 | 1]); &#125;int main() &#123; int n, m; char str[5]; while(~scanf(\"%d%d\", &amp;n, &amp;m)) &#123; BuildTree(1, n, 1); for(int i = 0; i &lt; m; i++) &#123; memset(str, 0 ,sizeof(str)); int a, b; scanf(\"%s\", str); scanf(\"%d%d\", &amp;a, &amp;b); if(str[0] == 'Q') &#123; int ans = Query(a, b, 1, n, 1); printf(\"%d\\n\",ans); &#125; else if(str[0] == 'U') &#123; Update(a, b, 1, n, 1); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"VJudge--Intervals","slug":"VJudge--Intervals","date":"2020-02-08T16:00:00.000Z","updated":"2020-02-09T14:01:27.939Z","comments":true,"path":"2020/02/09/VJudge--Intervals/","link":"","permalink":"http://yoursite.com/2020/02/09/VJudge--Intervals/","excerpt":"","text":"题目 - IntervalsThere is given the series of n closed intervals [ai; bi], where i=1,2,…,n. The sum of those intervals may be represented as a sum of closed pairwise non−intersecting intervals. The task is to find such representation with the minimal number of intervals. The intervals of this representation should be written in the output file in acceding order. We say that the intervals [a; b] and [c; d] are in ascending order if, and only if a &lt;= b &lt; c &lt;= d.TaskWrite a program which:reads from the std input the description of the series of intervals,computes pairwise non−intersecting intervals satisfying the conditions given above,writes the computed intervals in ascending order into std output Input In the first line of input there is one integer n, 3 &lt;= n &lt;= 50000. This is the number of intervals. In the (i+1)−st line, 1 &lt;= i &lt;= n, there is a description of the interval [ai; bi] in the form of two integers ai and bi separated by a single space, which are respectively the beginning and the end of the interval,1 &lt;= ai &lt;= bi &lt;= 1000000. Output The output should contain descriptions of all computed pairwise non−intersecting intervals. In each line should be written a description of one interval. It should be composed of two integers, separated by a single space, the beginning and the end of the interval respectively. The intervals should be written into the output in ascending order. Sample Input 12345655 61 410 106 98 10 Sample Output 121 45 10 题意：​ 区间覆盖，给很多线段，合并线段，使合并后的间隔最小。 解题：​ 写这个题目参考了今天暑假不AC AC代码：12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; int start, end;&#125;a[50005], b[5005];//这里bool cmp(node a, node b) &#123; return a.start &lt; b.start;&#125;int main() &#123; int n; while(~scanf(\"%d\",&amp;n)) &#123; for(int i = 0; i &lt; n; i++) &#123; scanf(\"%d %d\", &amp;a[i].start, &amp;a[i].end); &#125; sort(a, a + n, cmp); node last = a[0]; for(int i = 1; i &lt;= n-1; i++) &#123; if(a[i].start &lt;= last.end) &#123; //之前一直在这里wa，需要加一个判断条件(因为前一个线段可能包含后一个线段) if(a[i].end &gt; last.end) last.end = a[i].end; &#125; else if(a[i].start &gt; last.end) &#123; cout&lt;&lt;last.start&lt;&lt;\" \"&lt;&lt;last.end&lt;&lt;endl; last = a[i]; &#125; &#125; cout&lt;&lt;last.start&lt;&lt;\" \"&lt;&lt;last.end&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"VJudge--Task","slug":"VJudge--Task","date":"2020-02-08T16:00:00.000Z","updated":"2020-02-09T11:52:42.390Z","comments":true,"path":"2020/02/09/VJudge--Task/","link":"","permalink":"http://yoursite.com/2020/02/09/VJudge--Task/","excerpt":"","text":"题目 - TaskToday the company has m tasks to complete. The ith task need xi minutes to complete. Meanwhile, this task has a difficulty level yi. The machine whose level below this task’s level yi cannot complete this task. If the company completes this task, they will get (500xi+2yi) dollars.The company has n machines. Each machine has a maximum working time and a level. If the time for the task is more than the maximum working time of the machine, the machine can not complete this task. Each machine can only complete a task one day. Each task can only be completed by one machine.The company hopes to maximize the number of the tasks which they can complete today. If there are multiple solutions, they hopes to make the money maximum. Input The input contains several test cases.The first line contains two integers N and M. N is the number of the machines.M is the number of tasks(1 &lt; =N &lt;= 100000,1&lt;=M&lt;=100000).The following N lines each contains two integers xi(0&lt;xi&lt;1440),yi(0=&lt;yi&lt;=100).xi is the maximum time the machine can work.yi is the level of the machine.The following M lines each contains two integers xi(0&lt;xi&lt;1440),yi(0=&lt;yi&lt;=100).xi is the time we need to complete the task.yi is the level of the task. Output For each test case, output two integers, the maximum number of the tasks which the company can complete today and the money they will get. Sample Input 12341 2100 3100 2100 1 Sample Output 11 50004 题意：​ m个任务，每一个任务包括需要的时间和完成的难度，n台机器，每台任务有工作的最大时间和可以完成的任务的最大难度。完成一个任务可以获得奖金，最大时间&gt;=任务的时间，最大难度&gt;=任务的难度，这里要注意每个任务只能由一台机器完成，每台机器只能完成一个任务，要求：完成尽量多的任务，多种情况的时候，尽量使得奖金最多。 解题：​ 之前弄清题目意思，没有注意到每个任务只能由一台机器完成，每台机器只能完成一个任务。 ​ 弄清之后，可以这样考虑这道题，对于每个任务和机器不论是时间还是难度都从大到小排序，对于每个任务而言来找满足条件的机器，选择最大难度最小的那个，因为在找机器的过程是从大到小的所以在时间上是满足条件的，但难度就不一定所以，先用难度小的，保留难度大的。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;struct node &#123; int x, y;&#125;a[100005], b[100005];int vis[100005];bool cmp(node a, node b) &#123; if(a.x != b.x) return a.x &gt; b.x; else return a.y &gt; b.y;&#125;int main() &#123; int n, m; //这里要注意，多组测试样例 while(~scanf(\"%d %d\",&amp;n,&amp;m)) &#123; int ans = 0; //注意sum可能超出int型范围 long long sum = 0; for(int i = 0; i &lt; n; i++) &#123; scanf(\"%d %d\", &amp;a[i].x, &amp;a[i].y); &#125; for(int i = 0; i &lt; m; i++) &#123; scanf(\"%d %d\", &amp;b[i].x, &amp;b[i].y); &#125; sort(a, a + n, cmp); //这里写成了加n所以wa了 sort(b, b + m, cmp); memset(vis,0,sizeof(vis)); int j = 0; for(int i = 0; i &lt; m; i++) &#123; while(j &lt; n &amp;&amp; a[j].x &gt;= b[i].x) &#123; vis[a[j].y]++; ++j; &#125; for(int k = b[i].y; k &lt;= 100; k++) &#123; if(vis[k]) &#123; --vis[k]; ++ans; sum += 500 * b[i].x + 2 * b[i].y; break; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;\" \"&lt;&lt;sum&lt;&lt;endl;&#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"VJudge--Entropy","slug":"VJudge--Entropy","date":"2020-02-07T16:00:00.000Z","updated":"2020-02-09T09:31:32.371Z","comments":true,"path":"2020/02/08/VJudge--Entropy/","link":"","permalink":"http://yoursite.com/2020/02/08/VJudge--Entropy/","excerpt":"","text":"题目 - EntropyAn entropy encoder is a data encoding method that achieves lossless data compression by encoding a message with “wasted” or “extra” information removed. In other words, entropy encoding removes information that was not necessary in the first place to accurately encode the message. A high degree of entropy implies a message with a great deal of wasted information; english text encoded in ASCII is an example of a message type that has very high entropy. Already compressed messages, such as JPEG graphics or ZIP archives, have very little entropy and do not benefit from further attempts at entropy encoding. English text encoded in ASCII has a high degree of entropy because all characters are encoded using the same number of bits, eight. It is a known fact that the letters E, L, N, R, S and T occur at a considerably higher frequency than do most other letters in english text. If a way could be found to encode just these letters with four bits, then the new encoding would be smaller, would contain all the original information, and would have less entropy. ASCII uses a fixed number of bits for a reason, however: it’s easy, since one is always dealing with a fixed number of bits to represent each possible glyph or character. How would an encoding scheme that used four bits for the above letters be able to distinguish between the four-bit codes and eight-bit codes? This seemingly difficult problem is solved using what is known as a “prefix-free variable-length” encoding. In such an encoding, any number of bits can be used to represent any glyph, and glyphs not present in the message are simply not encoded. However, in order to be able to recover the information, no bit pattern that encodes a glyph is allowed to be the prefix of any other encoding bit pattern. This allows the encoded bitstream to be read bit by bit, and whenever a set of bits is encountered that represents a glyph, that glyph can be decoded. If the prefix-free constraint was not enforced, then such a decoding would be impossible. Consider the text “AAAAABCD”. Using ASCII, encoding this would require 64 bits. If, instead, we encode “A” with the bit pattern “00”, “B” with “01”, “C” with “10”, and “D” with “11” then we can encode this text in only 16 bits; the resulting bit pattern would be “0000000000011011”. This is still a fixed-length encoding, however; we’re using two bits per glyph instead of eight. Since the glyph “A” occurs with greater frequency, could we do better by encoding it with fewer bits? In fact we can, but in order to maintain a prefix-free encoding, some of the other bit patterns will become longer than two bits. An optimal encoding is to encode “A” with “0”, “B” with “10”, “C” with “110”, and “D” with “111”. (This is clearly not the only optimal encoding, as it is obvious that the encodings for B, C and D could be interchanged freely for any given encoding without increasing the size of the final encoded message.) Using this encoding, the message encodes in only 13 bits to “0000010110111”, a compression ratio of 4.9 to 1 (that is, each bit in the final encoded message represents as much information as did 4.9 bits in the original encoding). Read through this bit pattern from left to right and you’ll see that the prefix-free encoding makes it simple to decode this into the original text even though the codes have varying bit lengths. As a second example, consider the text “THE CAT IN THE HAT”. In this text, the letter “T” and the space character both occur with the highest frequency, so they will clearly have the shortest encoding bit patterns in an optimal encoding. The letters “C”, “I’ and “N” only occur once, however, so they will have the longest codes. There are many possible sets of prefix-free variable-length bit patterns that would yield the optimal encoding, that is, that would allow the text to be encoded in the fewest number of bits. One such optimal encoding is to encode spaces with “00”, “A” with “100”, “C” with “1110”, “E” with “1111”, “H” with “110”, “I” with “1010”, “N” with “1011” and “T” with “01”. The optimal encoding therefore requires only 51 bits compared to the 144 that would be necessary to encode the message with 8-bit ASCII encoding, a compression ratio of 2.8 to 1. Input The input file will contain a list of text strings, one per line. The text strings will consist only of uppercase alphanumeric characters and underscores (which are used in place of spaces). The end of the input will be signalled by a line containing only the word “END” as the text string. This line should not be processed. Output For each text string in the input, output the length in bits of the 8-bit ASCII encoding, the length in bits of an optimal prefix-free variable-length encoding, and the compression ratio accurate to one decimal point. Sample Input 123AAAAABCDTHE_CAT_IN_THE_HATEND Sample Output 1264 13 4.9144 51 2.8 题意：​ 输入字符串，分别用ACSII编码和Huffman编码，计算权值和比率 解题：​ 我那本算法书上给的用的STL的优先队列，我感觉还挺巧妙的。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;string s;//这里需要一个空格（我的编译器不支持）priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;int main() &#123; while(getline(cin, s) &amp;&amp; s != \"END\") &#123; sort(s.begin(), s.end()); int len = s.length(); int t = 1; for(int i = 1; i &lt; len; i++) &#123; if(s[i] == s[i-1]) ++t; else if(s[i] != s[i-1]) &#123; Q.push(t); t = 1; &#125; &#125; Q.push(t); int ans1 = len * 8; int ans2 = 0; if(Q.size() == 1) &#123; ans2 = Q.top(); &#125; while(true) &#123; int a = Q.top(); Q.pop(); if(Q.empty()) break; int b = Q.top(); Q.pop(); ans2 += (a + b); Q.push(a + b); &#125; cout&lt;&lt;ans1&lt;&lt;\" \"&lt;&lt;ans2&lt;&lt;\" \"&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;ans1 * 1.0 / ans2&lt;&lt;endl;&#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"VJudge--Just a Hook","slug":"VJudge--Just a Hook","date":"2020-02-07T16:00:00.000Z","updated":"2020-02-08T07:08:30.425Z","comments":true,"path":"2020/02/08/VJudge--Just a Hook/","link":"","permalink":"http://yoursite.com/2020/02/08/VJudge--Just%20a%20Hook/","excerpt":"","text":"题目 - Just a HookIn the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length. Now Pudge wants to do some operations on the hook. Let us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.The total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows: For each cupreous stick, the value is 1.For each silver stick, the value is 2.For each golden stick, the value is 3. Pudge wants to know the total value of the hook after performing the operations.You may consider the original hook is made up of cupreous sticks. Input The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.For each case, the first line contains an integer N, 1&lt;=N&lt;=100,000, which is the number of the sticks of Pudge’s meat hook and the second line contains an integer Q, 0&lt;=Q&lt;=100,000, which is the number of the operations.Next Q lines, each line contains three integers X, Y, 1&lt;=X&lt;=Y&lt;=N, Z, 1&lt;=Z&lt;=3, which defines an operation: change the sticks numbered from X to Y into the metal kind Z, where Z=1 represents the cupreous kind, Z=2 represents the silver kind and Z=3 represents the golden kind. Output For each case, print a number in a line representing the total value of the hook after the operations. Use the format in the example. Sample Input 1234511021 5 25 9 3 Sample Output 1Case 1: The total value of the hook is 24. 题意：​ 一个流星锤材质为铜(1)、银(2)、金(3)，默认为铜，求总重量. 解题：​ 线段树板子题，需要做些修改。在分析题目时可以发现树的每个结点存储的值就为换成的材质的重量，不需要考虑增加或者减少多少。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int MAXN = 1e5 + 10;long long sum[MAXN &lt;&lt; 2], add[MAXN &lt;&lt; 2];void push_down(int u, int m) &#123; if(add[u]) &#123; add[u &lt;&lt; 1] = add[u]; add[u &lt;&lt; 1 | 1] = add[u]; sum[u &lt;&lt; 1] = (m - (m &gt;&gt; 1)) * add[u]; sum[u &lt;&lt; 1 | 1] = (m &gt;&gt; 1) * add[u]; add[u] = 0; &#125;&#125;void BuildTree(int l, int r, int u) &#123; if(l == r) &#123; sum[u] = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; BuildTree(l, mid, u &lt;&lt; 1); BuildTree(mid + 1, r, u &lt;&lt; 1 | 1); sum[u] = sum[u &lt;&lt; 1] + sum[u &lt;&lt; 1 | 1];&#125;void Update(int a, int b, int c, int l, int r, int u) &#123; if(a &lt;= l &amp;&amp; b &gt;= r) &#123; sum[u] = (long long)(r - l + 1) * c; add[u] = c; return; &#125; push_down(u, r - l + 1); int mid = (r + l) &gt;&gt; 1; if(a &lt;= mid) Update(a, b, c, l, mid, u &lt;&lt; 1); if(b &gt; mid) Update(a, b, c, mid + 1, r, u &lt;&lt; 1 | 1); sum[u] = sum[u &lt;&lt; 1] + sum[u &lt;&lt; 1 | 1];&#125;long long Query(int a, int b, int l, int r, int u) &#123; if(a &lt;= l &amp;&amp; b &gt;= r) return sum[u]; push_down(u, r - l + 1); int mid = (l + r) &gt;&gt; 1; long long ans = 0; if(a &lt;= mid) ans += Query(a, b, l, mid, u &lt;&lt; 1); if(b &gt; mid) ans += Query(a, b, mid + 1, r, u &lt;&lt; 1 | 1); return ans;&#125;int main()&#123; int t; scanf(\"%d\",&amp;t); for(int i = 1; i &lt;= t; i++) &#123; memset(sum,0,sizeof(sum)); //这里失误写错了，然后就WA了 memset(add,0,sizeof(add)); int n, m; scanf(\"%d\",&amp;n); BuildTree(1, n, 1); scanf(\"%d\",&amp;m); for(int j = 1; j &lt;= m; j++) &#123; int a, b, c; scanf(\"%d %d %d\",&amp;a,&amp;b,&amp;c); Update(a, b, c, 1, n, 1); &#125; long long ans = Query(1, n, 1, n, 1); printf(\"Case %d: The total value of the hook is %d.\\n\",i,ans); &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"VJudge--Strange fuction","slug":"VJudge--Strange fuction","date":"2020-02-07T16:00:00.000Z","updated":"2020-02-09T09:36:07.184Z","comments":true,"path":"2020/02/08/VJudge--Strange fuction/","link":"","permalink":"http://yoursite.com/2020/02/08/VJudge--Strange%20fuction/","excerpt":"","text":"题目 - Strange fuctionNow, here is a fuction: F(x) = 6 * x^7+8x^6+7x^3+5x^2-yx (0 &lt;= x &lt;=100)Can you find the minimum value when x is between 0 and 100. Input The first line of the input contains an integer T(1&lt;=T&lt;=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 &lt; Y &lt;1e10) Output Just the minimum value (accurate up to 4 decimal places),when x is between 0 and 100. Sample Input 1232100200 Sample Output 12-74.4291-178.8534 题意：​ 输入y的值，大致估算该函数的最小值 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const double eps=1e-8; double y;int dir[2]=&#123;1,-1&#125;;double f(double x)&#123; return 6*pow(x,7) + 8*pow(x,6) + 7*pow(x,3) + 5*pow(x,2) - y*x;&#125; double anneal()&#123; double T=100; double delta=0.98; double x=50.0; double now=f(x); double ans=now; while(T&gt;eps) &#123; double nowx=x+dir[rand()%2]*T; if(nowx&gt;=0.0 &amp;&amp; nowx&lt;=100.0) &#123; now=f(nowx); if(ans-now&gt;eps) &#123; ans=now; x=nowx; &#125; &#125; T*=delta; &#125; return ans;&#125;int main()&#123; int i,j; int t; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%lf\",&amp;y); printf(\"%.4lf\\n\",anneal()); &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"模拟退火","slug":"模拟退火","permalink":"http://yoursite.com/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"}]},{"title":"VJudge--迷瘴","slug":"VJudge--迷瘴","date":"2020-02-07T16:00:00.000Z","updated":"2020-02-09T09:24:57.861Z","comments":true,"path":"2020/02/08/VJudge--迷瘴/","link":"","permalink":"http://yoursite.com/2020/02/08/VJudge--%E8%BF%B7%E7%98%B4/","excerpt":"","text":"题目 - 迷瘴通过悬崖的yifenfei，又面临着幽谷的考验——幽谷周围瘴气弥漫，静的可怕，隐约可见地上堆满了骷髅。由于此处长年不见天日，导致空气中布满了毒素，一旦吸入体内，便会全身溃烂而死。幸好yifenfei早有防备，提前备好了解药材料（各种浓度的万能药水）。现在只需按照配置成不同比例的浓度。现已知yifenfei随身携带有n种浓度的万能药水，体积V都相同，浓度则分别为Pi%。并且知道，针对当时幽谷的瘴气情况，只需选择部分或者全部的万能药水，然后配置出浓度不大于 W%的药水即可解毒。现在的问题是：如何配置此药，能得到最大体积的当前可用的解药呢？特别说明：由于幽谷内设备的限制,只允许把一种已有的药全部混入另一种之中（即：不能出现对一种药只取它的一部分这样的操作）。 Input 输入数据的第一行是一个整数C，表示测试数据的组数；每组测试数据包含2行，首先一行给出三个正整数n,V,W(1&lt;=n,V,W&lt;=100)；接着一行是n个整数，表示n种药水的浓度Pi%(1&lt;=Pi&lt;=100)。 Output 对于每组测试数据，请输出一个整数和一个浮点数；其中整数表示解药的最大体积，浮点数表示解药的浓度(四舍五入保留2位小数)；如果不能配出满足要求的的解药，则请输出0 0.00。 Sample Input 123456731 100 101002 100 2420 303 100 2420 20 30 Sample Output 1230 0.00100 0.20300 0.23 解题：​ 因为体积相同，所以浓度由低到高排序，然后循环取浓度小的药水，直到浓度大于W即可。 AC代码：12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; int a[105]; int t; scanf(\"%d\",&amp;t); while(t--) &#123; int n, v, w; scanf(\"%d %d %d\",&amp;n,&amp;v,&amp;w); for(int i = 0; i &lt; n; i++) scanf(\"%d\",&amp;a[i]); sort(a, a + n); int sum = 0; double w1 = w / 100.0; int k; double p; for(k = 0; k &lt; n; k++) &#123; sum +=a[k]; if((double)sum / ((double) (k+1) * 100) &gt; w1) break; else if((double)sum / ((double) (k+1) * 100) &lt;= w1) &#123; p = (double)sum / ((double) (k+1) * 100); &#125; &#125; if(k == 0) cout&lt;&lt;\"0 0.00\"&lt;&lt;endl; else cout&lt;&lt;k*v&lt;&lt;\" \"&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;p&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"NOI--和为给定数","slug":"NOI--和为给定数","date":"2020-02-05T16:00:00.000Z","updated":"2020-02-06T11:52:50.595Z","comments":true,"path":"2020/02/06/NOI--和为给定数/","link":"","permalink":"http://yoursite.com/2020/02/06/NOI--%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E6%95%B0/","excerpt":"","text":"07:和为给定数描述 给出若干个整数，询问其中是否有一对数的和等于给定的数。 输入 共三行：第一行是整数n(0 &lt; n &lt;= 100,000)，表示有n个整数。第二行是n个整数。整数的范围是在0到10^8之间。第三行是一个整数m（0 &lt;= m &lt;= 2^30)，表示需要得到的和。 输出 若存在和为m的数对，输出两个整数，小的在前，大的在后，中间用单个空格隔开。若有多个数对满足条件，选择数对中较小的数更小的。若找不到符合要求的数对，输出一行No。 样例输入 12342 5 1 46 样例输出 11 5 解题：WA了一次，发现如果测试数据为 12341 2 3 42 输出 1 1，实际上输出为“No”，说明不能重复找，所以把每次的查找起始位置换为该元素的下一个元素。 AC代码:12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int a[100005]; bool check(int x, int y) &#123; int l = y; int r = n; while(l &lt; r) &#123; int mid = (l + r) / 2; if(x &gt; a[mid]) l = mid + 1; else if(x &lt; a[mid])r = mid; else if(x == a[mid]) return true; &#125; return false;&#125;int main() &#123; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;a[i]; &#125; cin&gt;&gt;m; sort(a, a + n); for(int i = 0; i &lt; n; i++) &#123; int p = a[i]; int q = m - a[i]; //这里，每次查找从该元素的下一个元素开始找就不会重复啦 if(check(q, i + 1)) &#123; cout&lt;&lt;p&lt;&lt;\" \"&lt;&lt;q&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;\"No\"&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"NOI--矩阵分割","slug":"NOI--矩阵分割","date":"2020-02-05T16:00:00.000Z","updated":"2020-02-06T07:52:39.036Z","comments":true,"path":"2020/02/06/NOI--矩阵分割/","link":"","permalink":"http://yoursite.com/2020/02/06/NOI--%E7%9F%A9%E9%98%B5%E5%88%86%E5%89%B2/","excerpt":"","text":"03:矩形分割描述 平面上有一个大矩形，其左下角坐标（0，0），右上角坐标（R,R)。大矩形内部包含一些小矩形，小矩形都平行于坐标轴且互不重叠。所有矩形的顶点都是整点。要求画一根平行于y轴的直线x=k（k是整数) ，使得这些小矩形落在直线左边的面积必须大于等于落在右边的面积，且两边面积之差最小。并且，要使得大矩形在直线左边的的面积尽可能大。注意：若直线穿过一个小矩形，将会把它切成两个部分，分属左右两侧。 输入 第一行是整数R，表示大矩形的右上角坐标是(R,R) (1 &lt;= R &lt;= 1,000,000)。接下来的一行是整数N,表示一共有N个小矩形(0 &lt; N &lt;= 10000)。再接下来有N 行。每行有4个整数，L,T, W 和 H, 表示有一个小矩形的左上角坐标是(L,T),宽度是W，高度是H (0&lt;=L,T &lt;= R, 0 &lt; W,H &lt;= R). 小矩形不会有位于大矩形之外的部分。 输出 输出整数n，表示答案应该是直线 x=n。 如果必要的话，x=R也可以是答案。 样例输入 1234100021 1 2 15 1 2 1 样例输出 15 解题：以下面为例： 1234621 1 1 13 1 2 1 并记a[i]表示直线x=i-1与x=i之前的矩形面积，得a[1..6]={0，1，0，1，1，0}，前缀和s[1..6]={0，1，1，2，2，2}，那么问题可以这样处理：先二分找到满足左边矩形面积不小于右边矩形面积的第一个元素位置，这里是2——二分查找求下界，因为s[2]=s[3]，所以需要取3。 AC代码:1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int R, n;long long a[1000001], s[1000001];int Find(int l, int r) &#123; while(l &lt; r) &#123; int mid = l + (r - l) / 2; if(2 * s[mid] &gt;= s[R]) r = mid; else l = mid + 1; &#125; return l; &#125;int main() &#123; int L,T,W,H; cin&gt;&gt;R&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;L&gt;&gt;T&gt;&gt;W&gt;&gt;H; for(int j = 1; j &lt;= W; j++) &#123; a[L + j] += H; &#125; &#125; for(int i = 1; i &lt;= R; i++) &#123; s[i] = s[i-1] + a[i]; &#125; int t = Find(1, R); while(s[t] == s[t + 1] &amp;&amp; t &lt; R) t++; cout&lt;&lt;t&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"NOI--网线主管","slug":"NOI--网线主管","date":"2020-02-05T16:00:00.000Z","updated":"2020-02-06T12:40:15.773Z","comments":true,"path":"2020/02/06/NOI--网线主管/","link":"","permalink":"http://yoursite.com/2020/02/06/NOI--%E7%BD%91%E7%BA%BF%E4%B8%BB%E7%AE%A1/","excerpt":"","text":"04:网线主管描述 仙境的居民们决定举办一场程序设计区域赛。裁判委员会完全由自愿组成，他们承诺要组织一次史上最公正的比赛。他们决定将选手的电脑用星形拓扑结构连接在一起，即将它们全部连到一个单一的中心服务器。为了组织这个完全公正的比赛，裁判委员会主席提出要将所有选手的电脑等距离地围绕在服务器周围放置。 为购买网线，裁判委员会联系了当地的一个网络解决方案提供商，要求能够提供一定数量的等长网线。裁判委员会希望网线越长越好，这样选手们之间的距离可以尽可能远一些。 该公司的网线主管承接了这个任务。他知道库存中每条网线的长度（精确到厘米），并且只要告诉他所需的网线长度（精确到厘米），他都能够完成对网线的切割工作。但是，这次，所需的网线长度并不知道，这让网线主管不知所措。 你需要编写一个程序，帮助网线主管确定一个最长的网线长度，并且按此长度对库存中的网线进行切割，能够得到指定数量的网线。 输入 第一行包含两个整数N和K，以单个空格隔开。N（1 &lt;= N &lt;= 10000）是库存中的网线数，K（1 &lt;= K &lt;= 10000）是需要的网线数量。接下来N行，每行一个数，为库存中每条网线的长度（单位：米）。所有网线的长度至少1m，至多100km。输入中的所有长度都精确到厘米，即保留到小数点后两位。 输出 网线主管能够从库存的网线中切出指定数量的网线的最长长度（单位：米）。必须精确到厘米，即保留到小数点后两位。若无法得到长度至少为1cm的指定数量的网线，则必须输出“0.00”（不包含引号）。 样例输入 123454 118.027.434.575.39 样例输出 12.00 解题：​ 如果暴力枚举从[0,max]中的所有可能值，复杂度为O(max * n)不行，所以采用二分把复杂度降到o(n * log n)，写这个题注意下细节，小于1cm时不能算上。 AC代码:123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int a[10005];int n,k;bool check(int x) &#123; int sum = 0; for(int i = 0; i &lt; n; i++) &#123; sum += a[i] / x; &#125; if(sum &gt;= k) return true; else return false;&#125;int main() &#123; int max = 0; cin&gt;&gt;n&gt;&gt;k; for(int i = 0; i &lt; n; i++) &#123; double t; cin&gt;&gt;t; a[i] = t * 100; if(a[i] &gt; max) max = a[i]; &#125; int l = 0, r = max + 1; //这里用r-l&gt;1 while(r - l &gt; 1) &#123; int mid = (l + r) / 2; if(check(mid)) l = mid; else r = mid; &#125; //因为这个分母为100，Wa掉了 double ans = l / 100.0; printf(\"%.2lf\\n\",ans); return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"VJudge--A Simple Problem with Integers","slug":"VJudge--A Simple Problem with Integers","date":"2020-02-03T16:00:00.000Z","updated":"2020-02-04T09:54:35.406Z","comments":true,"path":"2020/02/04/VJudge--A Simple Problem with Integers/","link":"","permalink":"http://yoursite.com/2020/02/04/VJudge--A%20Simple%20Problem%20with%20Integers/","excerpt":"","text":"题目 - A Simple Problem with IntegersYou have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. Input The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c“ means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b“ means querying the sum of Aa, Aa+1, … , Ab. Output You need to answer all Q commands in order. One answer in a line. Sample Input 123456710 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4 Sample Output 1234455915 Hint The sums may exceed the range of 32-bit integers. 题目大意:​ 给出N个数，进行Q个操作，1&lt;=N，Q&lt;=100000。有两种操作： ​ “C a b c”,对区间[a,b]的每个数字加c ​ ”Q a b c”,查询区间[a,b]的数字和 解题：区间修改模板，TLE了一次。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int MAXN = 1e5 + 10;long long sum[MAXN &lt;&lt; 2], add[MAXN &lt;&lt; 2];void push_down(int u, int m) &#123; if(add[u]) &#123; add[u &lt;&lt; 1] += add[u]; add[u &lt;&lt; 1 | 1] += add[u]; sum[u &lt;&lt; 1] += (m - (m &gt;&gt; 1)) * add[u]; sum[u &lt;&lt; 1 | 1] += (m &gt;&gt; 1) * add[u]; add[u] = 0; &#125;&#125;void BuildTree(int l, int r, int u) &#123; if(l == r) &#123; cin&gt;&gt;sum[u]; return; &#125; int mid = (l + r) &gt;&gt; 1; BuildTree(l, mid, u &lt;&lt; 1); BuildTree(mid + 1, r, u &lt;&lt; 1 | 1); sum[u] = sum[u &lt;&lt; 1] + sum[u &lt;&lt; 1 | 1];&#125;void Update(int a, int b, long long int c, int l, int r, int u) &#123; if(a &lt;= l &amp;&amp; b &gt;= r) &#123; sum[u] += (r - l + 1) * c; add[u] += c; return; &#125; push_down(u, r - l + 1); int mid = (r + l) &gt;&gt; 1; if(a &lt;= mid) Update(a, b, c, l, mid, u &lt;&lt; 1); if(b &gt; mid) Update(a, b, c, mid + 1, r, u &lt;&lt; 1 | 1); sum[u] = sum[u &lt;&lt; 1] + sum[u &lt;&lt; 1 | 1];&#125;long long Query(int a, int b, int l, int r, int u) &#123; if(a &lt;= l &amp;&amp; b &gt;= r) return sum[u]; push_down(u, r - l + 1); int mid = (l + r) &gt;&gt; 1; long long ans = 0; if(a &lt;= mid) ans += Query(a, b, l, mid, u &lt;&lt; 1); if(b &gt; mid) ans += Query(a, b, mid + 1, r, u &lt;&lt; 1 | 1); return ans;&#125;int main()&#123; int n,m; //之前没有加这句话所以TLE了 while(~scanf(\"%d %d\",&amp;n,&amp;m))&#123; memset(add, 0, sizeof(add)); memset(sum, 0, sizeof(sum)); BuildTree(1,n,1); while(m--)&#123; char str[2]; int a,b; long long int c; cin&gt;&gt;str; if(str[0] == 'Q') &#123; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;Query(a,b,1,n,1)&lt;&lt;endl; &#125; else if(str[0] == 'C') &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; Update(a,b,c,1,n,1); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"VJudge--Lost Cows","slug":"VJudge--Lost Cows","date":"2020-02-03T16:00:00.000Z","updated":"2020-02-04T09:17:41.514Z","comments":true,"path":"2020/02/04/VJudge--Lost Cows/","link":"","permalink":"http://yoursite.com/2020/02/04/VJudge--Lost%20Cows/","excerpt":"","text":"E - Lost Cows N (2 &lt;= N &lt;= 8,000) cows have unique brands in the range 1..N. In a spectacular display of poor judgment, they visited the neighborhood ‘watering hole’ and drank a few too many beers before dinner. When it was time to line up for their evening meal, they did not line up in the required ascending numerical order of their brands. Regrettably, FJ does not have a way to sort them. Furthermore, he’s not very good at observing problems. Instead of writing down each cow’s brand, he determined a rather silly statistic: For each cow in line, he knows the number of cows that precede that cow in line that do, in fact, have smaller brands than that cow. Given this data, tell FJ the exact ordering of the cows. Input * Line 1: A single integer, N * Lines 2..N: These N-1 lines describe the number of cows that precede a given cow in line and have brands smaller than that cow. Of course, no cows precede the first cow in line, so she is not listed. Line 2 of the input describes the number of preceding cows whose brands are smaller than the cow in slot #2; line 3 describes the number of preceding cows whose brands are smaller than the cow in slot #3; and so on. Output * Lines 1..N: Each of the N lines of output tells the brand of a cow in line. Line #1 of the output tells the brand of the first cow in line; line 2 tells the brand of the second cow; and so on. Sample Input 1234551210 Sample Output 1234524531 题意：有编号是1~n的n个数字，2&lt;=n&lt;=8000,乱序排列，顺序是未知的。对于每个位置的数字，知道排在它前面比它小的数字有多少个。求这个乱序数列的顺序。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;const int MAX = 8005;struct&#123; int r,l,len;&#125;tree[4 * MAX];int pre[MAX],ans[MAX];void BuildTree(int l, int r, int u)&#123; tree[u].l = l; tree[u].r = r; tree[u].len = r - l + 1; if(l == r) return; BuildTree(l, (l+r)&gt;&gt;1, u&lt;&lt;1); BuildTree(((l+r)&gt;&gt;1) + 1, r, (u&lt;&lt;1) + 1);&#125;int Query(int u, int num)&#123; tree[u].len --; if(tree[u].l == tree[u].r) return tree[u].l; else if(tree[u&lt;&lt;1].len &lt; num) return Query((u &lt;&lt; 1) + 1, num - tree[u&lt;&lt;1].len); else if(tree[u&lt;&lt;1].len &gt;= num) return Query(u &lt;&lt; 1, num);&#125;int main()&#123; int n; cin&gt;&gt;n; pre[1] = 0; for(int i = 2; i &lt;= n; i++)&#123; cin&gt;&gt;pre[i]; &#125; BuildTree(1,n,1); for(int i = n; i &gt;= 1; i --)&#123; ans[i] = Query(1, pre[i] + 1); &#125; for(int i = 1; i &lt;= n; i ++)&#123; cout&lt;&lt;ans[i]&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"VJudge--敌兵布阵","slug":"VJudge--敌兵布阵","date":"2020-02-03T16:00:00.000Z","updated":"2020-02-04T10:04:27.663Z","comments":true,"path":"2020/02/04/VJudge--敌兵布阵/","link":"","permalink":"http://yoursite.com/2020/02/04/VJudge--%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5/","excerpt":"","text":"题目 - 敌兵布阵C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input 第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input 123456789101101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Output 1234Case 1:63359 解题：​ 一道线段树入门题，单点修改，WA了十六次，心态没了，人也没了。 ​ 十六WA心得体会: ​ 1.输入输出尽量用C语言的，别用cin/cout ​ 2.能简化代码就尽量简化别整这些有的没的 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;using namespace std;const int MAX = 50005;int sum[MAX &lt;&lt; 2];void BuildTree(int l, int r, int u) &#123; if(l == r) &#123; scanf(\"%d\",&amp;sum[u]); return; &#125; int mid = (l + r) &gt;&gt; 1; BuildTree(l, mid, u &lt;&lt; 1); BuildTree(mid + 1, r, u &lt;&lt; 1 | 1); sum[u] = sum[u &lt;&lt; 1] + sum[u &lt;&lt; 1 | 1];&#125;//之前写了两个函数Add和Sub,就是因为这个我WA了这么多次,原理一样，所以简化成一个void Update(int a, int b, int l, int r, int u) &#123; if(r == a &amp;&amp; l == a) &#123; sum[u] += b; return; &#125; int mid = (l + r) &gt;&gt; 1; if(a &lt;= mid) Update(a, b, l, mid, u &lt;&lt; 1); else Update(a, b, mid + 1, r, u &lt;&lt; 1 | 1); sum[u] = sum[u &lt;&lt; 1] + sum[u &lt;&lt; 1 | 1];&#125;int Query(int a, int b, int l, int r, int u) &#123; if(a &lt;= l &amp;&amp; b &gt;= r) return sum[u]; int mid = (l + r) &gt;&gt; 1; int ans = 0; if(a &lt;= mid) ans += Query(a, b, l, mid, u &lt;&lt; 1); if(b &gt; mid) ans += Query(a, b, mid + 1, r, u &lt;&lt; 1 | 1); return ans;&#125;int main()&#123; int T; int l = 0; int n; char s[10]; //输入和输出用C语言的 scanf(\"%d\",&amp;T); while(T--) &#123; printf(\"Case %d:\\n\",++l); scanf(\"%d\",&amp;n); BuildTree(1, n, 1); int a, b; while(1) &#123; scanf(\"%s\",s); if(s[0] == 'A') &#123; scanf(\"%d%d\",&amp;a,&amp;b); Update(a, b, 1, n, 1); &#125; else if(s[0] == 'S') &#123; scanf(\"%d%d\",&amp;a,&amp;b); Update(a, -b, 1, n, 1); &#125; else if(s[0] == 'Q') &#123; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",Query(a, b, 1, n, 1)); &#125; else break; &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"NOI--矩阵剪刀石头布","slug":"NOI--矩阵剪刀石头布","date":"2020-02-02T16:00:00.000Z","updated":"2020-02-03T01:55:35.381Z","comments":true,"path":"2020/02/03/NOI--矩阵剪刀石头布/","link":"","permalink":"http://yoursite.com/2020/02/03/NOI--%E7%9F%A9%E9%98%B5%E5%89%AA%E5%88%80%E7%9F%B3%E5%A4%B4%E5%B8%83/","excerpt":"","text":"16:矩阵剪刀石头布描述 Bart的妹妹Lisa在一个二维矩阵上创造了新的文明。矩阵上每个位置被三种生命形式之一占据：石头，剪刀，布。每天，上下左右相邻的不同生命形式将会发生战斗。在战斗中，石头永远胜剪刀，剪刀永远胜布，布永远胜石头。每一天结束之后，败者的领地将被胜者占领。 你的工作是计算出n天之后矩阵的占据情况。 输入 第一行包含三个正整数r，c，n，分别表示矩阵的行数、列数以及天数。每个整数均不超过100。接下来r行，每行c个字符，描述矩阵初始时被占据的情况。每个位置上的字符只能是R，S，P三者之一，分别代表石头，剪刀，布。相邻字符之间无空格。 输出 输出n天之后的矩阵占据情况。每个位置上的字符只能是R，S，P三者之一，相邻字符之间无空格。 样例输入 12343 3 1RRRRSRRRR 样例输出 123RRRRRRRRR AC代码:12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;char a[101][101],b[101][101];int main()&#123; int r,c,n,i,j; cin&gt;&gt;r&gt;&gt;c&gt;&gt;n; for(i=1;i&lt;=r;i++) for(j=1;j&lt;=c;j++) cin&gt;&gt;a[i][j]; for(int d=1;d&lt;=n;d++) &#123; //写之前没有缕清题意，没有加b数组存储每天修改之前的矩阵，这样的话每次修改相互影响 for(i=1;i&lt;=r;i++) for(j=1;j&lt;=c;j++) b[i][j]=a[i][j]; for(i=1;i&lt;=r;i++) for(j=1;j&lt;=c;j++) &#123; if(b[i][j]=='R'&amp;&amp;(b[i][j-1]=='P'||b[i-1][j]=='P'||b[i][j+1]=='P'||b[i+1][j]=='P')) a[i][j]='P'; if(b[i][j]=='S'&amp;&amp;(b[i][j-1]=='R'||b[i-1][j]=='R'||b[i][j+1]=='R'||b[i+1][j]=='R')) a[i][j]='R'; if(b[i][j]=='P'&amp;&amp;(b[i][j-1]=='S'||b[i-1][j]=='S'||b[i][j+1]=='S'||b[i+1][j]=='S')) a[i][j]='S'; &#125; &#125; for(i=1;i&lt;=r;i++) &#123; for(j=1;j&lt;=c;j++) cout&lt;&lt;a[i][j]; cout&lt;&lt;endl; &#125; return 0; &#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础编程","slug":"基础编程","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"ACM|时间复杂度","slug":"复杂度分析","date":"2020-02-02T16:00:00.000Z","updated":"2020-02-03T02:54:19.280Z","comments":true,"path":"2020/02/03/复杂度分析/","link":"","permalink":"http://yoursite.com/2020/02/03/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","excerpt":"","text":"如图：对应：O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)123456789101112131415在竞赛中，一般计算机一秒能运行5 x 10^8次计算，如果题目给出的限制时间在1s,那么你选择的算法执行的计算次数最多应该在10^8量级オ有可能解决这个题目，实际中还要考虑每种算法的常数。##### O(n)的算法能解决的数据范围在n &lt; 10^8。##### O(n *logn)的算法能解决的数据范围在n &lt;&#x3D; 10^6。##### O(n*sqrt(n) )的算法能解决的数据范围在n &lt; 10^5。##### O(n^2)的算法能解决的数据范围在n&lt;5000。##### O(n^3)的算法能解决的数据范围在n &lt;300。##### O(2^n)的算法能解决的数据范围在n &lt; 25。##### O(n!)的算法能解决的数据范围在n &lt; 11。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"复杂度","slug":"复杂度","permalink":"http://yoursite.com/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6/"}]},{"title":"NOI--单词替换","slug":"NOI--单词替换","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T14:14:59.702Z","comments":true,"path":"2020/02/02/NOI--单词替换/","link":"","permalink":"http://yoursite.com/2020/02/02/NOI--%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/","excerpt":"","text":"21:单词替换描述 输入一个字符串，以回车结束（字符串长度&lt;=100）。该字符串由若干个单词组成，单词之间用一个空格隔开，所有单词区分大小写。现需要将其中的某个单词替换成另一个单词，并输出替换之后的字符串。 输入 输入包括3行，第1行是包含多个单词的字符串 s;第2行是待替换的单词a(长度 &lt;= 100);第3行是a将被替换的单词b(长度 &lt;= 100). s, a, b 最前面和最后面都没有空格. 输出 输出只有 1 行，将s中所有单词a替换成b之后的字符串。 样例输入 123You want someone to help youYouI 样例输出 123You want someone to help youYouI AC代码:1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main()&#123; string s[100],a,b; char c; int n = 0; //感觉这个地方挺巧妙的 do &#123; cin&gt;&gt;s[n]; ++n; c = getchar(); &#125;while(c == ' '); cin&gt;&gt;a&gt;&gt;b; for(int i = 0; i &lt; n; i++)&#123; if(s[i] == a) s[i] = b; &#125; for(int i = 0; i &lt; n; i++)&#123; cout&lt;&lt;s[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础编程","slug":"基础编程","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"NOI--大整数减法","slug":"NOI--大整数减法","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T03:50:56.351Z","comments":true,"path":"2020/02/02/NOI--大整数减法/","link":"","permalink":"http://yoursite.com/2020/02/02/NOI--%E5%A4%A7%E6%95%B4%E6%95%B0%E5%87%8F%E6%B3%95/","excerpt":"","text":"11:大整数减法描述 求两个大的正整数相减的差。 输入 共2行，第1行是被减数a，第2行是减数b(a &gt; b)。每个大整数不超过200位，不会有多余的前导零。 输出 一行，即所求的差。 样例输入 1299999999999999999999999999999999999999999999999999 样例输出 19999999999999999999999990000000000000 //会写大整数加法这个题也没问题啦AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 205;int a[N];int b[N];int c[N];int main()&#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; int len1 = s1.length(); int len2 = s2.length(); while(len2&lt;len1)&#123; s2 = \"0\" + s2; ++len2; &#125; for(int i=0;i&lt;len1;i++)&#123; a[i] = s1[len1-1-i] - '0'; &#125; for(int i=0;i&lt;len1;i++)&#123; b[i] = s2[len2-1-i] - '0'; &#125; int len = 0; while(len&lt;len1)&#123; if(a[len]&lt;b[len])&#123; a[len+1] -= 1; c[len] = 10 + a[len] - b[len]; &#125; else if(a[len]&gt;=b[len]) c[len] = a[len] - b[len]; ++len; &#125; while(!c[len-1]&amp;&amp;len&gt;1)&#123; --len; &#125; for(int i=len-1;i&gt;=0;i--)&#123; cout&lt;&lt;c[i]; &#125; cout&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"高精度计算","slug":"高精度计算","permalink":"http://yoursite.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"}]},{"title":"NOI--大整数加法","slug":"NOI--大整数加法","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T03:50:46.148Z","comments":true,"path":"2020/02/02/NOI--大整数加法/","link":"","permalink":"http://yoursite.com/2020/02/02/NOI--%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/","excerpt":"","text":"10:大整数加法描述 求两个不超过200位的非负整数的和。 输入 有两行，每行是一个不超过200位的非负整数，可能有多余的前导0。 输出 一行，即相加后的结果。结果里不能有多余的前导0，即如果结果是342，那么就不能输出为0342。 样例输入 122222222222222222222233333333333333333333 样例输出 155555555555555555555 AC代码:12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 205;int a[N];int b[N];int c[N];int main()&#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; int len1 = s1.length(); int len2 = s2.length(); while(len1&lt;len2)&#123; //写的时候感觉这一步很巧妙，因为貌似有道题我用了很麻烦的方法加上前导0 s1 = \"0\" + s1; ++len1; &#125; while(len1&gt;len2)&#123; s2 = \"0\" + s2; ++len2; &#125; for(int i=0;i&lt;len1;i++)&#123; a[i] = s1[len1-1-i]-'0'; b[i] = s2[len1-1-i]-'0'; &#125; int len = 0; int x = 0; //之所以是len&lt;=len1两数相加的时候把它的结果最高位不管进不进位都多当作进位（后续有消除前导0操作 while(len&lt;=len1)&#123; c[len] = a[len] + b[len] + x; x = c[len] / 10; c[len] %= 10; ++len; &#125; //这一步是消除前导0，之前WA了是因为0+0时把0给消除了所以我增加了len&gt;1 while(!c[len-1]&amp;&amp;len&gt;1) --len; for(int i=len-1;i&gt;=0;i--)&#123; cout&lt;&lt;c[i]; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"高精度计算","slug":"高精度计算","permalink":"http://yoursite.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"}]},{"title":"NOI--大整数的因子","slug":"NOI--大整数的因子","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T03:50:11.261Z","comments":true,"path":"2020/02/02/NOI--大整数的因子/","link":"","permalink":"http://yoursite.com/2020/02/02/NOI--%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9A%84%E5%9B%A0%E5%AD%90/","excerpt":"","text":"13:大整数的因子描述 已知正整数k满足2&lt;=k&lt;=9，现给出长度最大为30位的十进制非负整数c，求所有能整除c的k。 输入 一个非负整数c，c的位数&lt;=30。 输出 若存在满足 c%k == 0 的k，从小到大输出所有这样的k，相邻两个数之间用单个空格隔开；若没有这样的k，则输出”none”。 样例输入 130 样例输出 12 3 5 6 思路:这是高精度除于单精度的题目，从高位到低位依次除以k，求余数，如果最后余数为0，说明能被k整除。AC代码:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 30;int a[N];int main()&#123; string s; int flag = 0; cin&gt;&gt;s; int len = s.length(); //因为除是从高位往低位所以从高到低进行存储 for(int i = 0; i &lt; len; i++) &#123; a[i] = s[i] - '0'; &#125; for(int k = 2; k &lt;= 9; k++) &#123; int t = 0; for(int i = 0; i &lt; len; i++) &#123; t = t * 10 + a[i]; t %= k; &#125; if(t == 0) &#123; cout&lt;&lt;k&lt;&lt;\" \"; flag = 1; &#125; &#125; if(!flag) cout&lt;&lt;\"none\"; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"高精度计算","slug":"高精度计算","permalink":"http://yoursite.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"}]},{"title":"NOI--字符串移位包含问题","slug":"NOI--字符串移位包含问题","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T14:40:35.705Z","comments":true,"path":"2020/02/02/NOI--字符串移位包含问题/","link":"","permalink":"http://yoursite.com/2020/02/02/NOI--%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%BB%E4%BD%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/","excerpt":"","text":"19:字符串移位包含问题描述 对于一个字符串来说，定义一次循环移位操作为：将字符串的第一个字符移动到末尾形成新的字符串。 给定两个字符串s1和s2，要求判定其中一个字符串是否是另一字符串通过若干次循环移位后的新字符串的子串。例如CDAA是由AABCD两次移位后产生的新串BCDAA的子串，而ABCD与ACBD则不能通过多次移位来得到其中一个字符串是新串的子串。 输入 一行，包含两个字符串，中间由单个空格隔开。字符串只包含字母和数字，长度不超过30。 输出 如果一个字符串是另一字符串通过若干次循环移位产生的新串的子串，则输出true，否则输出false。 样例输入 1AABCD CDAA 样例输出 1true AC代码:123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; //为啥直接相加呢因为移位找子串其实就是两个字符串相加，操作也挺简单的 string s3 = s1 + s1; string s4 = s2 + s2; //之前WA了三次，原因是并没有理解题目中是求一个串是否包含另一个串而我只考虑了s1串包含s2 if(s3.find(s2)!=-1&amp;&amp;s1.size()&gt;=s2.size()) cout&lt;&lt;\"true\"&lt;&lt;endl; else if(s4.find(s1)!=-1&amp;&amp;s1.size()&lt;s2.size()) cout&lt;&lt;\"true\"&lt;&lt;endl; else cout&lt;&lt;\"false\"&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础编程","slug":"基础编程","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"NOI--求10000以内n的阶乘","slug":"NOI--求10000以内n的阶乘","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T09:09:08.209Z","comments":true,"path":"2020/02/02/NOI--求10000以内n的阶乘/","link":"","permalink":"http://yoursite.com/2020/02/02/NOI--%E6%B1%8210000%E4%BB%A5%E5%86%85n%E7%9A%84%E9%98%B6%E4%B9%98/","excerpt":"","text":"14:求10000以内n的阶乘描述 求10000以内n的阶乘。 输入 只有一行输入，整数n（0&lt;=n&lt;=10000）。 输出 一行，即n!的值。 样例输入 1100 样例输出 193326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 题解：由低位到高位计算每一位数字与i相乘的数再依次进位，这里要注意的是算出的最高位的数不一定是2位数，也可以用万进制来计算。AC代码:1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1000000;int a[N];int main()&#123; int n; cin&gt;&gt;n; memset(a,0,sizeof(a)); a[0] = 1; a[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; int x = 0; for(int j = 1; j &lt;= a[0]; j++) &#123; a[j] = a[j] * i + x; x = a[j] / 10; a[j] %= 10; &#125; //注意的是算出的最高位的数不一定是2位数，因为之前这里我用的if来判断只能计算到32！ while(x&gt;0) &#123; a[a[0]+1] += x % 10; ++a[0]; x /= 10; &#125; &#125; for(int i = a[0]; i &gt;= 1; i--) &#123; cout&lt;&lt;a[i]; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"高精度计算","slug":"高精度计算","permalink":"http://yoursite.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"}]},{"title":"NOI--计算2的N次方","slug":"NOI--计算2的N次方","date":"2020-01-31T16:00:00.000Z","updated":"2020-02-02T03:14:44.344Z","comments":true,"path":"2020/02/01/NOI--计算2的N次方/","link":"","permalink":"http://yoursite.com/2020/02/01/NOI--%E8%AE%A1%E7%AE%972%E7%9A%84N%E6%AC%A1%E6%96%B9/","excerpt":"","text":"12:计算2的N次方描述 任意给定一个正整数N(N&lt;=100)，计算2的n次方的值。 输入 输入一个正整数N。 输出 输出2的N次方的值。 样例输入 15 样例输出 132 思路:这是高精度×单精度的题目，由于要考虑进位所以从低位到高位上的数字依次乘2，然后再逐位判断是否进位。AC代码:123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 50;int a[N];int main()&#123; int n; cin&gt;&gt;n; memset(a,0,sizeof(a)); //a[0]用来存储位数 a[0] = 1; //a[1]为了方便下面计算a[1]位上的数 a[1] = 1; for(int i=0;i&lt;n;i++)&#123; //由低位到高位依次计算每一位上的数字 for(int i=1;i&lt;=a[0];i++)&#123; a[i] *= 2; &#125; //判断每一位是否需要进位 for(int i=1;i&lt;=a[0];i++)&#123; if(a[i]&gt;=10)&#123; a[i] %= 10; a[i+1] += 1; &#125; &#125; //最高位如果进位了，位数需要加1 if(a[a[0]+1]) ++a[0]; &#125; for(int i=a[0];i&gt;=1;i--)&#123; cout&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"高精度计算","slug":"高精度计算","permalink":"http://yoursite.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/"}]},{"title":"NOI--单词倒排","slug":"NOI--单词倒排","date":"2020-01-30T16:00:00.000Z","updated":"2020-02-01T03:09:30.893Z","comments":true,"path":"2020/01/31/NOI--单词倒排/","link":"","permalink":"http://yoursite.com/2020/01/31/NOI--%E5%8D%95%E8%AF%8D%E5%80%92%E6%8E%92/","excerpt":"","text":"28:单词倒排描述 编写程序，读入一行英文(只包含字母和空格，单词间以单个空格分隔)，将所有单词的顺序倒排并输出，依然以单个空格分隔。 输入 输入为一个字符串（字符串长度至多为100）。 输出 输出为按要求排序后的字符串。 样例输入 1I am a student 样例输出 1student a am I AC代码:12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s,str; int len; getline(cin,str); len = str.length(); s+=\" \"; for(int i=0;i&lt;len;i++)&#123; s+=str[i]; &#125; int i = s.length()-1; int j = i; while(i&gt;=0)&#123; if(s[i] != ' ')&#123; --i; continue; &#125; else if(s[i] == ' ')&#123; for(int p = i+1;p&lt;=j;p++) cout&lt;&lt;s[p]; cout&lt;&lt;\" \"; j = i-1; --i; &#125;&#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础编程","slug":"基础编程","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"NOI--单词翻转","slug":"NOI--单词翻转","date":"2020-01-30T16:00:00.000Z","updated":"2020-02-01T03:09:10.609Z","comments":true,"path":"2020/01/31/NOI--单词翻转/","link":"","permalink":"http://yoursite.com/2020/01/31/NOI--%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%BD%AC/","excerpt":"","text":"27:单词翻转描述 输入一个句子（一行），将句子中的每一个单词翻转后输出。 输入 只有一行，为一个字符串，不超过500个字符。单词之间以空格隔开。 输出 翻转每一个单词后的字符串，单词之间的空格需与原文一致。 样例输入 1hello world 样例输出 1olleh dlrow //这个题其实和单词倒排差不多，一个星期前做这个题的时候PE了六次，把单词倒排AC之后再去做这个题特别快。 AC代码:12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; getline(cin,s); int len = s.length(); int j = 0; int i = j; while(j&lt;=len)&#123; if(s[j] != ' '&amp;&amp;s[j] != '\\0')&#123; ++j; continue; &#125; else if(s[j]==' '||s[j]=='\\0')&#123; for(int k=j-1;k&gt;=i;k--)&#123; cout&lt;&lt;s[k]; &#125; cout&lt;&lt;\" \"; ++j; i = j; &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础编程","slug":"基础编程","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"NOI--字符环","slug":"NOI--字符环","date":"2020-01-30T16:00:00.000Z","updated":"2020-02-01T03:08:23.176Z","comments":true,"path":"2020/01/31/NOI--字符环/","link":"","permalink":"http://yoursite.com/2020/01/31/NOI--%E5%AD%97%E7%AC%A6%E7%8E%AF/","excerpt":"","text":"30:字符环描述 有两个由字符构成的环。请写一个程序，计算这两个字符环上最长连续公共字符串的长度。例如，字符串“ABCEFAGADEGKABUVKLM”的首尾连在一起，构成一个环；字符串“MADJKLUVKL”的首尾连在一起，构成一个另一个环；“UVKLMA”是这两个环的一个连续公共字符串。 输入 一行，包含两个字符串，分别对应一个字符环。这两个字符串之间用单个空格分开。字符串长度不超过255，且不包含空格等空白符。 输出 输出一个整数，表示这两个字符环上最长公共字符串的长度。 样例输入 1ABCEFAGADEGKABUVKLM MADJKLUVKL 样例输出 16 解题：AC代码:12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s,str; int len; getline(cin,str); len = str.length(); s+=\" \"; for(int i=0;i&lt;len;i++)&#123; s+=str[i]; &#125; int i = s.length()-1; int j = i; while(i&gt;=0)&#123; if(s[i] != ' ')&#123; --i; continue; &#125; else if(s[i] == ' ')&#123; for(int p = i+1;p&lt;=j;p++) cout&lt;&lt;s[p]; cout&lt;&lt;\" \"; j = i-1; --i; &#125;&#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础编程","slug":"基础编程","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"NOI--第n小的质数","slug":"NOI--第n小的质数","date":"2020-01-28T16:00:00.000Z","updated":"2020-01-31T02:34:06.394Z","comments":true,"path":"2020/01/29/NOI--第n小的质数/","link":"","permalink":"http://yoursite.com/2020/01/29/NOI--%E7%AC%ACn%E5%B0%8F%E7%9A%84%E8%B4%A8%E6%95%B0/","excerpt":"","text":"44:第n小的质数描述 输入一个正整数n，求第n小的质数。 输入 一个不超过10000的正整数n。 输出 第n小的质数。 样例输入 110 样例输出 129 AC代码:123456789101112131415161718192021222324252627#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;bool isprime(int x)&#123; if(x&#x3D;&#x3D;1) return false; else if(x &#x3D;&#x3D; 2) return true; else &#123; for(int i&#x3D;2;i&lt;&#x3D;sqrt(x);i++)&#123; if(x%i&#x3D;&#x3D;0) return false; &#125; return true; &#125;&#125;int main()&#123; int n; int s &#x3D; 0; cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;1000000;i++)&#123; if(isprime(i)) ++s; if(s &#x3D;&#x3D; n)&#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础编程","slug":"基础编程","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"搜索专题","slug":"ACM训练--搜索算法","date":"2020-01-27T16:00:00.000Z","updated":"2020-04-21T12:41:22.182Z","comments":true,"path":"2020/01/28/ACM训练--搜索算法/","link":"","permalink":"http://yoursite.com/2020/01/28/ACM%E8%AE%AD%E7%BB%83--%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/","excerpt":"","text":"之前虽然学过搜索，感觉忘了很多，所以写一遍博客来回忆一下。 深度优先搜索（DFS)和广度优先搜索(BFS)是基本的暴力技术。 一般来说用队列这种数据结构来实现BFS,用栈这种数据结构来实现DFS（用递归来实现)。 经典BFS：贴一个🔗http://lx.lanqiao.cn/problem.page?gpid=T291 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int m, n;int maze[505][505];bool vis[505][505];//下左右上 int dir[4][2] = &#123;&#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;&#125;;char r[4] = &#123;'D', 'L', 'R', 'U'&#125;;struct node &#123; int x; int y; int step; string road;&#125;;bool check(int x, int y) &#123; if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; !vis[x][y] &amp;&amp; maze[x][y] == 0) return true; return false;&#125;void BFS(int x, int y) &#123; queue &lt;node&gt; q; node st, ne; st.x = x; st.y = y; st.step = 0; st.road = \"\"; vis[x][y] = true; q.push(st); while(!q.empty()) &#123; st = q.front(); q.pop(); if(st.x == n - 1 &amp;&amp; st.y == m - 1) &#123; cout &lt;&lt; st.step &lt;&lt; endl &lt;&lt; st.road &lt;&lt; endl; return; &#125; for(int i = 0; i &lt; 4; ++i) &#123; ne.x = st.x + dir[i][0]; ne.y = st.y + dir[i][1]; if(check(ne.x, ne.y)) &#123; vis[ne.x][ne.y] = true; ne.step = st.step + 1; ne.road = st.road + r[i]; q.push(ne); &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; //这个地方我感觉还是有点坑的，测试数据连续输入不加空格 scanf(\"%1d\", &amp;maze[i][j]); &#125; &#125; BFS(0, 0); return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"深搜","slug":"深搜","permalink":"http://yoursite.com/tags/%E6%B7%B1%E6%90%9C/"},{"name":"广搜","slug":"广搜","permalink":"http://yoursite.com/tags/%E5%B9%BF%E6%90%9C/"}]},{"title":"NOI--铺地毯","slug":"NOI--铺地毯","date":"2020-01-27T16:00:00.000Z","updated":"2020-01-31T04:42:13.016Z","comments":true,"path":"2020/01/28/NOI--铺地毯/","link":"","permalink":"http://yoursite.com/2020/01/28/NOI--%E9%93%BA%E5%9C%B0%E6%AF%AF/","excerpt":"","text":"题目描述铺地毯 总时间限制: 1000ms 内存限制: 65536kB 描述 为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有n张地毯，编号从1到n。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。输入输出样例1说明：如下图，1号地毯用实线表示，2号地毯用虚线表示，3号用双实线表示，覆盖点（2，2）的最上面一张地毯是3号地毯。输入输出样例2说明：如下图，1号地毯用实线表示，2号地毯用虚线表示，3号用双实线表示，覆盖点（4，5）的最上面一张地毯是3号地毯。 输入 输入共n+2行。 第一行，一个整数n，表示总共有n张地毯。 接下来的n行中，第i+1行表示编号i的地毯的信息，包含四个正整数a，b，g，k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标（a，b）以及地毯在x轴和y轴方向的长度。 第n+2行包含两个正整数x和y，表示所求的地面的点的坐标（x，y）。 对于30%的数据，有n≤2； 对于50%的数据，0≤a, b, g, k≤100； 对于100%的数据，有0≤n≤10,000，0≤a, b, g, k≤100,000。 输出 输出共1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1。 样例输入 12345678910111213样例 #1：31 0 2 30 2 3 32 1 3 32 2样例 #2：31 0 2 30 2 3 32 1 3 34 5 样例输出 12345样例 #1：3样例 #2：-1 AC代码：123456789101112131415161718192021222324252627#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 100001;int a[N];int b[N];int g[N];int k[N];int main()&#123; int n; int x,y; cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;g[i]&gt;&gt;k[i]; &#125; cin&gt;&gt;x&gt;&gt;y; for(int i&#x3D;n;i&gt;&#x3D;1;i--)&#123; if(x&gt;&#x3D;a[i]&amp;&amp;x&lt;&#x3D;a[i]+g[i]&amp;&amp;y&gt;&#x3D;b[i]&amp;&amp;y&lt;&#x3D;b[i]+k[i])&#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础编程","slug":"基础编程","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"NOI--找最大数序列","slug":"NOI--1.9-10找最大数序列","date":"2020-01-20T16:00:00.000Z","updated":"2020-01-21T12:12:55.279Z","comments":true,"path":"2020/01/21/NOI--1.9-10找最大数序列/","link":"","permalink":"http://yoursite.com/2020/01/21/NOI--1.9-10%E6%89%BE%E6%9C%80%E5%A4%A7%E6%95%B0%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目描述10:找最大数序列 总时间限制: 1000ms 内存限制: 65536kB 描述 输入n行，每行不超过100个无符号整数，无符号数不超过4位。请输出最大整数以及最大整数所在的行号（行号从1开始）。如果该数据在多个行中出现，则按从小到大输出相应行号，行号之间以一个逗号分开。 输入 一行输入一个正整数n（n &lt;= 30）。 之后的n行，每行包含不超过100个无符号整数，整数之间以一个逗号分开。 输出 第一行：最大整数； 第二行：最大整数所在的行编号，逗号间隔。 样例输入 123456761,3,5,23,6,8,1420,22,13,4,1623,12,17,222,6,10,9,3,622,21,20,8,1022,1,23,6,8,19,23 样例输出 12231,3,6 思路: 注意一下输入格式。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 10000;int a[N];int b[N];int d[N];int main()&#123; int n; cin&gt;&gt;n; char c; for(int i&#x3D;0;i&lt;n;i++)&#123; memset(a,0,sizeof(a)); int j&#x3D;0; do&#123; cin&gt;&gt;a[j++]; &#125;while(getchar()!&#x3D;&#39;\\n&#39;); sort(a,a+j); b[i] &#x3D; a[j-1];&#125; int max &#x3D; -1; for(int i&#x3D;0;i&lt;n;i++)&#123; if(b[i]&gt;max) max &#x3D; b[i]; &#125; cout&lt;&lt;max&lt;&lt;endl; int k&#x3D;0; for(int i&#x3D;0;i&lt;n;i++)&#123; if(b[i]&#x3D;&#x3D;max) d[k++] &#x3D; i+1; &#125; cout&lt;&lt;d[0]; for(int i&#x3D;1;i&lt;k;i++)&#123; cout&lt;&lt;&quot;,&quot;&lt;&lt;d[i]; &#125; cout&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础编程","slug":"基础编程","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"NOI--错误探测","slug":"NOI--错误探测","date":"2020-01-20T16:00:00.000Z","updated":"2020-01-23T09:19:20.124Z","comments":true,"path":"2020/01/21/NOI--错误探测/","link":"","permalink":"http://yoursite.com/2020/01/21/NOI--%E9%94%99%E8%AF%AF%E6%8E%A2%E6%B5%8B/","excerpt":"","text":"04:错误探测 总时间限制: 1000ms 内存限制: 65536kB 描述 给定n*n由0和1组成的矩阵，如果矩阵的每一行和每一列的1的数量都是偶数，则认为符合条件。 你的任务就是检测矩阵是否符合条件，或者在仅改变一个矩阵元素的情况下能否符合条件。 “改变矩阵元素”的操作定义为0变成1或者1变成0。 输入 输入n + 1行，第1行为矩阵的大小n(0 &lt; n &lt; 100)，以下n行为矩阵的每一行的元素，元素之间以一个空格分开。 输出 如果矩阵符合条件，则输出OK； 如果矩阵仅改变一个矩阵元素就能符合条件，则输出需要改变的元素所在的行号和列号，以一个空格分开。 如果不符合以上两条，输出Corrupt。 样例输入 1234567891011121314151617181920样例输入141 0 1 00 0 0 01 1 1 10 1 0 1样例输入241 0 1 00 0 1 01 1 1 10 1 0 1样例输入341 0 1 00 1 1 01 1 1 10 1 0 1 样例输出 12345678样例输出1OK样例输出22 3样例输出3Corrupt WA代码：123456789101112131415161718192021222324252627282930#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int M &#x3D; 100+5;const int N &#x3D; 100+5;int a[M][N]&#x3D;&#123;0&#125;;int main()&#123; int n; int c &#x3D; 0,r &#x3D; 0; cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123; cin&gt;&gt;a[i][j]; a[0][j] &#x3D; (a[0][j]+a[i][j])%2;&#x2F;&#x2F;感觉这个地方还是很巧妙的(get) a[i][0] &#x3D; (a[i][0]+a[i][j])%2; &#125; &#125; for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123; if(a[0][j]&#x3D;&#x3D;1) r &#x3D; j; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; if(a[i][0]&#x3D;&#x3D;1) c &#x3D; i; &#125; if(c&#x3D;&#x3D;0&amp;&amp;r&#x3D;&#x3D;0) cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl; else if(c!&#x3D;0&amp;&amp;r!&#x3D;0)cout&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl; else cout&lt;&lt;&quot;Corrupt&quot;&lt;&lt;endl; return 0;&#125; 感觉思路也没什么问题，写了几组数据测试发现其中一组数据有问题 1234540 0 0 01 1 0 10 0 0 11 1 1 1 当有多行/列为奇数时，只返回第一组检测的序号。（其实这个时候应该是Corrupt) 所以应该增加两个变量来记录行或列为奇数的行数/列数。 AC代码:123456789101112131415161718192021222324252627282930313233343536#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int M &#x3D; 100+5;const int N &#x3D; 100+5;int a[M][N]&#x3D;&#123;0&#125;;int main()&#123; int n; int c &#x3D; 0,r &#x3D; 0,c1 &#x3D; 0,r1 &#x3D; 0; cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123; cin&gt;&gt;a[i][j]; a[0][j] &#x3D; (a[0][j]+a[i][j])%2; a[i][0] &#x3D; (a[i][0]+a[i][j])%2; &#125; &#125; for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123; if(a[0][j]&#x3D;&#x3D;1)&#123; r &#x3D; j; r1++; &#125; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; if(a[i][0]&#x3D;&#x3D;1)&#123; c &#x3D; i; c1++; &#125;&#125; if(c1&#x3D;&#x3D;0&amp;&amp;r1&#x3D;&#x3D;0) cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl; else if(c1&#x3D;&#x3D;1&amp;&amp;r1&#x3D;&#x3D;1)cout&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl; else cout&lt;&lt;&quot;Corrupt&quot;&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基础编程","slug":"基础编程","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"校园导航","slug":"校园导航","date":"2020-01-09T16:00:00.000Z","updated":"2020-01-19T10:33:45.915Z","comments":true,"path":"2020/01/10/校园导航/","link":"","permalink":"http://yoursite.com/2020/01/10/%E6%A0%A1%E5%9B%AD%E5%AF%BC%E8%88%AA/","excerpt":"","text":"校园导航-STD这是之前数据结构做的一个图的实验。 一、题目要求图是应用极为广泛的数据结构，也是这门课程的重点。它的特点在于非线性。稀疏矩阵 的十字链表存储结构也是图的一种存储结构，故也把它们归在这次实习中。本 章 实习继续突 出了数据结构加操作的程序设计观点，但根据这两种结构的非线性特点，将 操 作 进一步集中 在遍历操作上，因为遍历操作是其他众多操作的基础。遍历逻辑的（或符号形式的）结构， 访问动作可是任何操作。本 次 实习还希望达到熟悉各种存储结构的特征，以及如何应用树和 图结构解决具体问题（即原理与应用的结合）等目的。 图的基本操作 [问题描述] 分别用邻接矩阵和邻接表实现以下操作：图的创建、遍历、插入、删除、最短路径。 [基本要求] 熟悉图的常用存储结构和基本操作 二、设计思路先构造数据 所有地点:春晖楼 开元楼 图书馆 十栋 基教 学院楼 消社 任意两个地点的路径长度： 春晖楼 开元楼 50 春晖楼 图书馆 300 春晖楼 基教 400 开元楼 基教 200 基教 学院楼 50 学院楼 图书馆 10 十栋 开元楼 250 十栋 消社 20 消社 基教 100 增加的地点: 消社 招待所 700 学院楼 招待所 450 构建一个无向网 用邻接矩阵来存储任意两个地点的关系。 图的遍历用DFS递归来输出地点，任意两点间的最短路径用弗洛伊德算法。 三、代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;#define MaxInt 32767#define MVNum 100typedef string VerTexType;typedef int ArcType;int vis[MVNum]&#x3D;&#123;0&#125;;int n&#x3D;0;int Path[MVNum][MVNum];int D[MVNum][MVNum];typedef struct&#123; VerTexType vexs[MVNum]; ArcType arcs[MVNum][MVNum]; int vexnum,arcnum;&#125;AMGraph;int LocateVex(AMGraph G,string u)&#123; for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)&#123; if(u&#x3D;&#x3D;G.vexs[i]) &#123; return i; break; &#125; else continue; &#125;&#125;void Create(AMGraph &amp;G)&#123; int w; string v1,v2; printf(&quot;请输入总地点数和路径数:&quot;); cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; printf(&quot;请输入所有地点:\\n&quot;);&#x2F;&#x2F;春晖楼 开元楼 图书馆 十栋 基教 学院楼消社 for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)&#123; cin&gt;&gt;G.vexs[i]; &#125; for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++) for(int j&#x3D;1;j&lt;&#x3D;G.vexnum;j++) G.arcs[i][j]&#x3D;MaxInt; for(int k&#x3D;1;k&lt;&#x3D;G.arcnum;k++)&#123; printf(&quot;请输入两个地点及其路径:&quot;); cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; int m&#x3D;LocateVex(G,v1); int n&#x3D;LocateVex(G,v2); G.arcs[m][n]&#x3D;w; G.arcs[n][m]&#x3D;w;&#125;&#125; void Display(AMGraph G,int v)&#123; if(n&gt;G.vexnum) return; if(!vis[v])&#123; vis[v]&#x3D;1; cout&lt;&lt;G.vexs[v]&lt;&lt;&quot; &quot;; for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)&#123; if(G.arcs[v][i]!&#x3D;MaxInt&amp;&amp;vis[i]&#x3D;&#x3D;0) &#123; n++; Display(G,i); &#125; else continue;&#125;&#125;&#125;void Insert(AMGraph &amp;G)&#123; int w; string v1,v2; printf(&quot;请输入你要增加的地点和路径的数目:&quot;); int p,q; cin&gt;&gt;p&gt;&gt;q; int t&#x3D;G.vexnum; G.vexnum+&#x3D;p; G.arcnum+&#x3D;q; for(int k&#x3D;t+1;k&lt;&#x3D;G.vexnum;k++)&#123; for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++) G.arcs[i][k]&#x3D;MaxInt; for(int j&#x3D;1;j&lt;&#x3D;G.vexnum;j++) G.arcs[k][j]&#x3D;MaxInt; &#125; cout&lt;&lt;&quot;请输入增加的地点:&quot;; for(int i&#x3D;t+1;i&lt;&#x3D;G.vexnum;i++) cin&gt;&gt;G.vexs[i]; for(int i&#x3D;1;i&lt;&#x3D;q;i++)&#123; printf(&quot;请输入两个地点及其路径:&quot;); cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; int m&#x3D;LocateVex(G,v1); int n&#x3D;LocateVex(G,v2); G.arcs[m][n]&#x3D;w; G.arcs[n][m]&#x3D;w; &#125; &#125; void Delete(AMGraph &amp;G)&#123; int l&#x3D;0; string u; cout&lt;&lt;&quot;请输入要删除的地点:&quot;; cin&gt;&gt;u; int t&#x3D;LocateVex(G,u); for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)&#123; if(G.arcs[t][i]!&#x3D;MaxInt) l++; &#125; G.arcnum-&#x3D;l; for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)&#123; G.arcs[i][t]&#x3D;MaxInt; G.arcs[t][i]&#x3D;MaxInt; &#125; G.vexs[t]&#x3D;&quot;&quot;;&#125;void Floyd(AMGraph G)&#123; int i,j,k; for (i&#x3D;1;i&lt;&#x3D;G.vexnum;i++) for (j&#x3D;1;j&lt;&#x3D;G.vexnum;j++) &#123; D[i][j] &#x3D; G.arcs[i][j]; if (D[i][j]&lt;MaxInt &amp;&amp; i!&#x3D;j) Path[i][j] &#x3D; i; else Path[i][j] &#x3D; -1; &#125; for(k&#x3D;1;k&lt;&#x3D;G.vexnum;k++) for(i&#x3D;1;i&lt;&#x3D;G.vexnum;i++) for(j&#x3D;1;j&lt;&#x3D;G.vexnum;j++) if(D[i][k]+D[k][j]&lt;D[i][j]) &#123; D[i][j] &#x3D; D[i][k] + D[k][j]; Path[i][j] &#x3D; Path[k][j]; &#125;&#125; void ShortPath(AMGraph G)&#123; string s1,s2; int vs,ve,x,temp; cout&lt;&lt;&quot;请输入起点和终点:&quot;; cin&gt;&gt;s1&gt;&gt;s2; vs&#x3D;LocateVex(G,s1); ve&#x3D;LocateVex(G,s2); cout&lt;&lt;&quot;最短路径长为：&quot;; cout&lt;&lt;D[vs][ve]&lt;&lt;endl; stack&lt;int&gt; sta; sta.push(ve); x &#x3D; ve; while (Path[vs][x]!&#x3D;vs) &#123; sta.push(Path[vs][x]); x &#x3D; Path[vs][x]; &#125; sta.push(vs); cout&lt;&lt;&quot;最短路径为: &quot;; temp &#x3D; sta.top(); sta.pop(); cout&lt;&lt;G.vexs[temp]; while (!sta.empty()) &#123; temp &#x3D; sta.top(); sta.pop(); cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;G.vexs[temp]; &#125; puts(&quot;&quot;);&#125;void menu()&#123; cout&lt;&lt;&quot;*********************************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;-----------------石家庄铁道大学校园导航------------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;*********************************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 1. 图的创建 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 2. 图的遍历 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 3. 图的插入 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 4. 图的删除 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 5. 最短路径 *&quot;&lt;&lt;endl; cout&lt;&lt;&quot;* 0. 返回主界面 *&quot;&lt;&lt;endl; &#125; int main()&#123; AMGraph G; int k; int t1,t2,t3; string v,u; menu(); while(1)&#123; cout&lt;&lt;&quot;请选择:&quot;&lt;&lt;endl; cin&gt;&gt;k; switch (k)&#123; case 1: Create(G);break; case 2: printf(&quot;请输入出发点:&quot;); cin&gt;&gt;v; cout&lt;&lt;&quot;从出发点开始遍历的路线为:&quot;; t1&#x3D;LocateVex(G,v); Display(G,t1); cout&lt;&lt;endl; break; case 3: Insert(G); printf(&quot;请输入出发点:&quot;); cin&gt;&gt;u; cout&lt;&lt;&quot;从出发点开始遍历的路线为:&quot;; t2&#x3D;LocateVex(G,u); n&#x3D;0; memset(vis,0,sizeof(vis)); Display(G,t2); cout&lt;&lt;endl; break; case 4: Delete(G); printf(&quot;请输入出发点:&quot;); cin&gt;&gt;u; cout&lt;&lt;&quot;从出发点开始遍历的路线为:&quot;; t3&#x3D;LocateVex(G,u); n&#x3D;0; memset(vis,0,sizeof(vis)); Display(G,t3); cout&lt;&lt;endl; break; case 5: Floyd(G); ShortPath(G); break; case 0: menu(); break; &#125;&#125; return 0;&#125; 四、功能测试","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"图","slug":"图","permalink":"http://yoursite.com/tags/%E5%9B%BE/"}]},{"title":"VJudge--二叉搜索树","slug":"二叉搜索树","date":"2019-12-07T16:00:00.000Z","updated":"2020-01-19T10:43:07.070Z","comments":true,"path":"2019/12/08/二叉搜索树/","link":"","permalink":"http://yoursite.com/2019/12/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"题目 - A Bug’s LifeBackgroundProfessor Hopper is researching the sexual behavior of a rare species of bugs. He assumes that they feature two different genders and that they only interact with bugs of the opposite gender. In his experiment, individual bugs and their interactions were easy to identify, because numbers were printed on their backs.ProblemGiven a list of bug interactions, decide whether the experiment supports his assumption of two genders with no homosexual bugs or if it contains some bug interactions that falsify it. Input The first line of the input contains the number of scenarios. Each scenario starts with one line giving the number of bugs (at least one, and up to 2000) and the number of interactions (up to 1000000) separated by a single space. In the following lines, each interaction is given in the form of two distinct bug numbers separated by a single space. Bugs are numbered consecutively starting from one. Output The output for every scenario is a line containing “Scenario #i:”, where i is the number of the scenario starting at 1, followed by one line saying either “No suspicious bugs found!” if the experiment is consistent with his assumption about the bugs’ sexual behavior, or “Suspicious bugs found!” if Professor Hopper’s assumption is definitely wrong. Sample Input 1234567823 31 22 31 34 21 23 4 Sample Output 12345Scenario #1:Suspicious bugs found!Scenario #2:No suspicious bugs found! Hint Huge input,scanf is recommended. 题目大意:t组数据，n个虫子，m组相互喜爱的关系，虫子分为雌雄两种，每个虫子只有一个性别，问是否存在同性恋的虫子。 思路：与犯罪团伙那个题差不多。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;int pre[20010];int r[20010];&#x2F;&#x2F;&#x2F;r&#x3D;0代表与根节点同性int Find(int x)&#123; int t; if(pre[x]&#x3D;&#x3D;x) &#123; return x; &#125; t&#x3D;pre[x]; pre[x]&#x3D;Find(pre[x]);&#x2F;&#x2F;&#x2F;压缩路径 r[x]&#x3D;(r[x]+r[t]+1)%2; return pre[x];&#125;void Union(int a,int b)&#123; int x,y; x&#x3D;Find(a); y&#x3D;Find(b); pre[x]&#x3D;y; r[x]&#x3D;(r[b]-r[a])%2;&#125;int main()&#123; int t,i,j,k,flag; int n,m,a,b; scanf(&quot;%d&quot;,&amp;t); for(k&#x3D;1;k&lt;&#x3D;t;k++) &#123; flag&#x3D;0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i&#x3D;1; i&lt;&#x3D;n; i++) &#123; r[i]&#x3D;1; pre[i]&#x3D;i; &#125; for(i&#x3D;1; i&lt;&#x3D;m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(Find(a)&#x3D;&#x3D;Find(b)) &#123; if(r[a]&#x3D;&#x3D;r[b])&#x2F;&#x2F;&#x2F;同性 &#123; flag&#x3D;1; &#125; &#125; else &#123; Union(a,b); &#125; &#125; if(flag) &#123; printf(&quot;Scenario #%d:\\nSuspicious bugs found!\\n\\n&quot;,k); &#125; else &#123; printf(&quot;Scenario #%d:\\nNo suspicious bugs found!\\n\\n&quot;,k); &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"BST","slug":"BST","permalink":"http://yoursite.com/tags/BST/"}]},{"title":"VJudge--Farm Irrigation","slug":"Farm Irrigation ","date":"2019-12-03T16:00:00.000Z","updated":"2020-01-19T10:44:20.615Z","comments":true,"path":"2019/12/04/Farm Irrigation /","link":"","permalink":"http://yoursite.com/2019/12/04/Farm%20Irrigation%20/","excerpt":"","text":"题目 - Farm IrrigationBenny has a spacious farm land to irrigate. The farm land is a rectangle, and is divided into a lot of samll squares. Water pipes are placed in these squares. Different square has a different type of pipe. There are 11 types of pipes, which is marked from A to K, as Figure 1 shows. Figure 1 Benny has a map of his farm, which is an array of marks denoting the distribution of water pipes over the whole farm. For example, if he has a map ADCFJKIHE then the water pipes are distributed like Figure 2 Several wellsprings are found in the center of some squares, so water can flow along the pipes from one square to another. If water flow crosses one square, the whole farm land in this square is irrigated and will have a good harvest in autumn. Now Benny wants to know at least how many wellsprings should be found to have the whole farm land irrigated. Can you help him? Note: In the above example, at least 3 wellsprings are needed, as those red points in Figure 2 show. Input There are several test cases! In each test case, the first line contains 2 integers M and N, then M lines follow. In each of these lines, there are N characters, in the range of ‘A’ to ‘K’, denoting the type of water pipe over the corresponding square. A negative M or N denotes the end of input, else you can assume 1 &lt;= M, N &lt;= 50. Output For each test case, output in one line the least number of wellsprings needed. Sample Input 123456789102 2DKHF3 3ADCFJKIHE-1 -1 Sample Output 1223 题目大意:浇灌田地，图中的蓝色的线代表水管，水管能连起来的用一个泉源即可浇灌，问浇灌这片田地用需要多少个泉源。 思路：求用的源泉数就是求有几个不连通的图，遍历每块田地，只要考虑它和左边和上边的田地是否能并合并就可以了。对于左边和上边哪两块能够合并，由图可知： 上联通：ABEGHJK下联通：CDEHIJK左联通：ACFGHIK右联通：BDFGIJK AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;const int N&#x3D;52;char maze[N][N];int parent[N*N];void init(int n)&#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) parent[i]&#x3D;i;&#125;int find(int x)&#123; return parent[x]&#x3D;&#x3D;x?x:find(parent[x]);&#125;void unite(int x,int y)&#123; x&#x3D;find(x); y&#x3D;find(y); if(x&#x3D;&#x3D;y) return; parent[x]&#x3D;y;&#125;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n!&#x3D;-1&amp;&amp;m!&#x3D;-1) &#123; init(n*m); for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; cin&gt;&gt;maze[i][j]; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;1;j&lt;&#x3D;m;j++) &#123; if(j-1&gt;&#x3D;1) &#123; if((maze[i][j-1]&#x3D;&#x3D;&#39;B&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;D&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;F&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;G&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;I&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;J&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;K&#39;) &amp;&amp;(maze[i][j]&#x3D;&#x3D;&#39;C&#39;||maze[i][j]&#x3D;&#x3D;&#39;F&#39;||maze[i][j]&#x3D;&#x3D;&#39;G&#39;||maze[i][j]&#x3D;&#x3D;&#39;H&#39;||maze[i][j]&#x3D;&#x3D;&#39;I&#39;||maze[i][j]&#x3D;&#x3D;&#39;A&#39;||maze[i][j]&#x3D;&#x3D;&#39;K&#39;)) unite((i-1)*m+j-1,(i-1)*m+j); &#125; if(i-1&gt;&#x3D;1) &#123; if((maze[i-1][j]&#x3D;&#x3D;&#39;C&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;D&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;E&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;H&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;I&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;J&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;K&#39;)&amp;&amp; (maze[i][j]&#x3D;&#x3D;&#39;A&#39;||maze[i][j]&#x3D;&#x3D;&#39;B&#39;||maze[i][j]&#x3D;&#x3D;&#39;E&#39;||maze[i][j]&#x3D;&#x3D;&#39;G&#39;||maze[i][j]&#x3D;&#x3D;&#39;H&#39;||maze[i][j]&#x3D;&#x3D;&#39;J&#39;||maze[i][j]&#x3D;&#x3D;&#39;K&#39;)) unite((i-1-1)*m+j,(i-1)*m+j); &#125; &#125; int num&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n*m;i++) if(parent[i]&#x3D;&#x3D;i) num++; cout&lt;&lt;num&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"VJudge--Is It A Tree?","slug":"Is It A Tree ","date":"2019-12-02T16:00:00.000Z","updated":"2020-01-19T10:43:58.979Z","comments":true,"path":"2019/12/03/Is It A Tree /","link":"","permalink":"http://yoursite.com/2019/12/03/Is%20It%20A%20Tree%20/","excerpt":"","text":"题目 - Is It A Tree?A tree is a well-known data structure that is either empty (null, void, nothing) or is a set of one or more nodes connected by directed edges between nodes satisfying the following properties.There is exactly one node, called the root, to which no directed edges point. Every node except the root has exactly one edge pointing to it. There is a unique sequence of directed edges from the root to each node. For example, consider the illustrations below, in which nodes are represented by circles and edges are represented by lines with arrowheads. The first two of these are trees, but the last is not. In this problem you will be given several descriptions of collections of nodes connected by directed edges. For each of these you are to determine if the collection satisfies the definition of a tree or not. Input The input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers; the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero. Output For each test case display the line Case k is a tree.&quot; or the lineCase k is not a tree.”, where k corresponds to the test case number (they are sequentially numbered starting with 1). Sample Input 12345676 8 5 3 5 2 6 45 6 0 08 1 7 3 6 2 8 9 7 57 4 7 8 7 6 0 03 8 6 8 6 45 3 5 6 5 2 0 0-1 -1 Sample Output 123Case 1 is a tree.Case 2 is a tree.Case 3 is not a tree. 题目大意:判断给出的数据能否构成一颗树。 思路：构成一颗有向树的条件: 不能有环 只有一个根即只有一个入度为0的点，否则是森林 除了根结点之外的其他点的入度为1 任意两个点之间都能连通 然后注意一下空树也算树。 计算根节点个数，然后除根结点之外其他的入度均要为1，判断是否是森林，即只有一个根节点。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;using namespace std;const int MAX&#x3D;1e4+10;int pre[MAX];int in[MAX];int vis[MAX];void init()&#123; int i; for(i&#x3D;1; i&lt;MAX; i++) &#123; vis[i]&#x3D;0; in[i]&#x3D;0; pre[i]&#x3D;i; &#125;&#125;int Find(int x)&#123; if(pre[x]&#x3D;&#x3D;x) &#123; return x; &#125; else &#123; return Find(pre[x]); &#125;&#125;void Union(int root1,int root2)&#123; int x,y; x&#x3D;Find(root1); y&#x3D;Find(root2); if(x!&#x3D;y) &#123; pre[x]&#x3D;y; &#125;&#125;int main()&#123; int i,root,counts,a,b,flag,ans&#x3D;1; while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!&#x3D;EOF) &#123; if(a&#x3D;&#x3D;-1&amp;&amp;b&#x3D;&#x3D;-1) &#123; break; &#125; if(a&#x3D;&#x3D;0&amp;&amp;b&#x3D;&#x3D;0) &#123; printf(&quot;Case %d is a tree.\\n&quot;,ans); ans++; continue; &#125; init(); vis[a]&#x3D;1; vis[b]&#x3D;1; in[b]++; Union(a,b); while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!&#x3D;EOF) &#123; if(a&#x3D;&#x3D;0&amp;&amp;b&#x3D;&#x3D;0) &#123; break; &#125; vis[a]&#x3D;1; vis[b]&#x3D;1; in[b]++; Union(a,b); &#125; flag&#x3D;1; root&#x3D;0; counts&#x3D;0; for(i&#x3D;1;i&lt;MAX;i++) &#123; if(vis[i]&amp;&amp;in[i]&#x3D;&#x3D;0) &#123; root++; &#125; if(in[i]&gt;&#x3D;2) &#123; flag&#x3D;0; &#125; if(vis[i]&amp;&amp;pre[i]&#x3D;&#x3D;i) &#123; counts++; &#125; &#125; if(root!&#x3D;1||counts&gt;1) &#123; flag&#x3D;0; &#125; if(flag) &#123; printf(&quot;Case %d is a tree.\\n&quot;,ans); ans++; &#125; else &#123; printf(&quot;Case %d is not a tree.\\n&quot;,ans); ans++; &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"带权并查集","slug":"带权并查集","permalink":"http://yoursite.com/tags/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"VJudge--More is better","slug":"More is better","date":"2019-12-02T16:00:00.000Z","updated":"2020-01-19T10:43:45.764Z","comments":true,"path":"2019/12/03/More is better/","link":"","permalink":"http://yoursite.com/2019/12/03/More%20is%20better/","excerpt":"","text":"题目 - More is betterMr Wang wants some boys to help him with a project. Because the project is rather complex, the more boys come, the better it will be. Of course there are certain requirements. Mr Wang selected a room big enough to hold the boys. The boy who are not been chosen has to leave the room immediately. There are 10000000 boys in the room numbered from 1 to 10000000 at the very beginning. After Mr Wang’s selection any two of them who are still in this room should be friends (direct or indirect), or there is only one boy left. Given all the direct friend-pairs, you should decide the best way. Input The first line of the input contains an integer n (0 ≤ n ≤ 100 000) - the number of direct friend-pairs. The following n lines each contains a pair of numbers A and B separated by a single space that suggests A and B are direct friends. (A ≠ B, 1 ≤ A, B ≤ 10000000) Output The output in one line contains exactly one integer equals to the maximum number of boys Mr Wang may keep. Sample Input 1234567891041 23 45 61 641 23 45 67 8 Sample Output 1242 Hint 12345A and B are friends(direct or indirect), B and C are friends(direct or indirect), then A and C are also friends(indirect). In the first sample &#123;1,2,5,6&#125; is the result.In the second sample &#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;,&#123;7,8&#125; are four kinds of answers. 题目大意:A和B是朋友（直接或间接），B和C是朋友（直接或间接），那么A和C也是朋友（间接）。 在第一个样本{1,2,5,6}中是结果。在第二个示例{1,2}，{3,4}，{5,6}，{7,8}中有四种答案。 思路： 比上道龙珠题简单的多其实都差不多 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define maxn 110000int N, sum;int per[maxn], ran[maxn]; void init() &#123; sum &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; maxn; ++i)&#123; per[i] &#x3D; i; ran[i] &#x3D; 1; &#125;&#125; int find(int x)&#123; int r &#x3D; x; while( r !&#x3D; per[r]) r &#x3D; per[r]; per[x] &#x3D; r; return r;&#125; void join (int a, int b)&#123; int fa &#x3D; find(a); int fb &#x3D; find(b); if(fa !&#x3D; fb)&#123; per[fa] &#x3D; fb; ran[fb] +&#x3D; ran[fa]; sum &#x3D; max(sum, ran[fb]); &#125;&#125; int main ()&#123; while(scanf(&quot;%d&quot;, &amp;N) !&#x3D; EOF)&#123; init(); if(N &#x3D;&#x3D; 0)&#123; printf(&quot;1\\n&quot;); continue; &#125; while(N--)&#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); join(a, b); &#125; printf(&quot;%d\\n&quot;, sum); &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"带权并查集","slug":"带权并查集","permalink":"http://yoursite.com/tags/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"VJudge--小希的迷宫","slug":"小希的迷宫","date":"2019-12-02T16:00:00.000Z","updated":"2020-01-19T10:41:55.448Z","comments":true,"path":"2019/12/03/小希的迷宫/","link":"","permalink":"http://yoursite.com/2019/12/03/%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB/","excerpt":"","text":"题目 - 小希的迷宫上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 Input 输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。整个文件以两个-1结尾。 Output 对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。 Sample Input 123456789106 8 5 3 5 2 6 45 6 0 08 1 7 3 6 2 8 9 7 57 4 7 8 7 6 0 03 8 6 8 6 45 3 5 6 5 2 0 0-1 -1 Sample Output 123YesYesNo 题目大意:判断该图是不是连通并且无环的。 思路：用并查集来判断是否是连通的。 如果父节点相同，则有环。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1e5+10;int par[N];bool vis[N];int Find(int x)&#123; if(par[x] &#x3D;&#x3D; x) return x; return par[x] &#x3D; Find(par[x]);&#125;bool unite(int x,int y)&#123; x &#x3D; Find(x); y &#x3D; Find(y); if(x !&#x3D; y) &#123; par[x] &#x3D; y; return true; &#125; return false;&#125;int main()&#123; int a, b; while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b)) &#123; if(a&#x3D;&#x3D;-1 &amp;&amp; b&#x3D;&#x3D;-1) break; if(a&#x3D;&#x3D;0 &amp;&amp; b&#x3D;&#x3D;0) &#123; printf(&quot;Yes\\n&quot;); continue; &#125; for(int i &#x3D; 0; i &lt;&#x3D; N; i++) par[i] &#x3D; i; unite(a,b); vis[a] &#x3D; vis[b] &#x3D; true; bool flag &#x3D; true; while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b) &amp;&amp; a) &#123; bool ans &#x3D; unite(a,b); vis[a] &#x3D; vis[b] &#x3D; true; if(!ans) flag &#x3D; false; &#125; int k &#x3D; 0; for(int i &#x3D; 0; i &lt; N; i++) &#123; if(vis[i] &amp;&amp; par[i]&#x3D;&#x3D;i) k++; &#125; if(k &gt; 1) flag &#x3D; false; if(flag) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125;return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"VJudge--Dragon Balls","slug":"Dragon Balls","date":"2019-12-01T16:00:00.000Z","updated":"2020-01-19T10:44:31.495Z","comments":true,"path":"2019/12/02/Dragon Balls/","link":"","permalink":"http://yoursite.com/2019/12/02/Dragon%20Balls/","excerpt":"","text":"题目 - Dragon BallsFive hundred years later, the number of dragon balls will increase unexpectedly, so it’s too difficult for Monkey King(WuKong) to gather all of the dragon balls together.His country has N cities and there are exactly N dragon balls in the world. At first, for the ith dragon ball, the sacred dragon will puts it in the ith city. Through long years, some cities’ dragon ball(s) would be transported to other cities. To save physical strength WuKong plans to take Flying Nimbus Cloud, a magical flying cloud to gather dragon balls.Every time WuKong will collect the information of one dragon ball, he will ask you the information of that ball. You must tell him which city the ball is located and how many dragon balls are there in that city, you also need to tell him how many times the ball has been transported so far. Input The first line of the input is a single positive integer T(0 &lt; T &lt;= 100).For each case, the first line contains two integers: N and Q (2 &lt; N &lt;= 10000 , 2 &lt; Q &lt;= 10000).Each of the following Q lines contains either a fact or a question as the follow format: T A B : All the dragon balls which are in the same city with A have been transported to the city the Bth ball in. You can assume that the two cities are different. Q A : WuKong want to know X (the id of the city Ath ball is in), Y (the count of balls in Xth city) and Z (the tranporting times of the Ath ball). (1 &lt;= A, B &lt;= N) Output For each test case, output the test case number formated as sample output. Then for each query, output a line with three integers X Y Z saparated by a blank space. Sample Input 1234567891023 3T 1 2T 3 2Q 23 4T 1 2Q 1T 1 3Q 1 Sample Output 12345Case 1:2 3 0Case 2:2 2 13 3 2 题目大意:初始时，有n个龙珠，编号从1到n，分别对应的放在编号从1到n的城市中。现在有两种操作： T A B，表示把A球所在城市全部的龙珠全部转移到B城市。（第一次时，因为A球所在的城市只有一个球，所以只移动1个，如果有多个，则全部移动）。 Q A，表示查询A。要求得到的信息分别是：A现在所在的城市，A所在城市的龙珠数目，A转移到该城市移动的次数（如果没有移动就输出0） 思路： qwq嫌弃..这个字也太丑了！！ AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;using namespace std;const int maxn&#x3D;1e5+10;int f[maxn];int sum[maxn];int Move[maxn];int n,m;void init_set()&#123; for(int i&#x3D;1; i&lt;&#x3D;n; i++) &#123; f[i]&#x3D;i; sum[i]&#x3D;1; Move[i]&#x3D;0; &#125;&#125;int find_set(int x)&#123; if(x!&#x3D;f[x]) &#123; int t&#x3D;f[x]; f[x]&#x3D;find_set(f[x]); Move[x]+&#x3D;Move[t]; return f[x]; &#125; return x;&#125;void unit_set(int x,int y)&#123; x&#x3D;find_set(x); y&#x3D;find_set(y); if(x&#x3D;&#x3D;y)return; f[x]&#x3D;y; sum[y]+&#x3D;sum[x]; Move[x]++;&#125;int main()&#123; int t; int l&#x3D;0; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; l++; printf(&quot;Case %d:\\n&quot;,l); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init_set(); for(int i&#x3D;0; i&lt;m; i++) &#123; char s[6]; scanf(&quot;%s&quot;,s); if(s[0]&#x3D;&#x3D;&#39;T&#39;) &#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); unit_set(x,y); &#125; else if(s[0]&#x3D;&#x3D;&#39;Q&#39;) &#123; int x; scanf(&quot;%d&quot;,&amp;x); int ans&#x3D;find_set(x); printf(&quot;%d %d %d\\n&quot;,ans,sum[ans],Move[x]); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"带权并查集","slug":"带权并查集","permalink":"http://yoursite.com/tags/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"VJudge--A Bug's Life","slug":"A Bug's Life","date":"2019-11-30T16:00:00.000Z","updated":"2020-01-19T10:40:27.605Z","comments":true,"path":"2019/12/01/A Bug's Life/","link":"","permalink":"http://yoursite.com/2019/12/01/A%20Bug's%20Life/","excerpt":"","text":"题目 - A Bug’s LifeBackgroundProfessor Hopper is researching the sexual behavior of a rare species of bugs. He assumes that they feature two different genders and that they only interact with bugs of the opposite gender. In his experiment, individual bugs and their interactions were easy to identify, because numbers were printed on their backs.ProblemGiven a list of bug interactions, decide whether the experiment supports his assumption of two genders with no homosexual bugs or if it contains some bug interactions that falsify it. Input The first line of the input contains the number of scenarios. Each scenario starts with one line giving the number of bugs (at least one, and up to 2000) and the number of interactions (up to 1000000) separated by a single space. In the following lines, each interaction is given in the form of two distinct bug numbers separated by a single space. Bugs are numbered consecutively starting from one. Output The output for every scenario is a line containing “Scenario #i:”, where i is the number of the scenario starting at 1, followed by one line saying either “No suspicious bugs found!” if the experiment is consistent with his assumption about the bugs’ sexual behavior, or “Suspicious bugs found!” if Professor Hopper’s assumption is definitely wrong. Sample Input 1234567823 31 22 31 34 21 23 4 Sample Output 12345Scenario #1:Suspicious bugs found!Scenario #2:No suspicious bugs found! Hint Huge input,scanf is recommended. 题目大意:t组数据，n个虫子，m组相互喜爱的关系，虫子分为雌雄两种，每个虫子只有一个性别，问是否存在同性恋的虫子。 思路：与犯罪团伙那个题差不多。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;int pre[20010];int r[20010];&#x2F;&#x2F;&#x2F;r&#x3D;0代表与根节点同性int Find(int x)&#123; int t; if(pre[x]&#x3D;&#x3D;x) &#123; return x; &#125; t&#x3D;pre[x]; pre[x]&#x3D;Find(pre[x]);&#x2F;&#x2F;&#x2F;压缩路径 r[x]&#x3D;(r[x]+r[t]+1)%2; return pre[x];&#125;void Union(int a,int b)&#123; int x,y; x&#x3D;Find(a); y&#x3D;Find(b); pre[x]&#x3D;y; r[x]&#x3D;(r[b]-r[a])%2;&#125;int main()&#123; int t,i,j,k,flag; int n,m,a,b; scanf(&quot;%d&quot;,&amp;t); for(k&#x3D;1;k&lt;&#x3D;t;k++) &#123; flag&#x3D;0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i&#x3D;1; i&lt;&#x3D;n; i++) &#123; r[i]&#x3D;1; pre[i]&#x3D;i; &#125; for(i&#x3D;1; i&lt;&#x3D;m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(Find(a)&#x3D;&#x3D;Find(b)) &#123; if(r[a]&#x3D;&#x3D;r[b])&#x2F;&#x2F;&#x2F;同性 &#123; flag&#x3D;1; &#125; &#125; else &#123; Union(a,b); &#125; &#125; if(flag) &#123; printf(&quot;Scenario #%d:\\nSuspicious bugs found!\\n\\n&quot;,k); &#125; else &#123; printf(&quot;Scenario #%d:\\nNo suspicious bugs found!\\n\\n&quot;,k); &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"VJudge--Find them, Catch them","slug":"Find them, Catch them","date":"2019-11-30T16:00:00.000Z","updated":"2020-01-19T10:44:11.175Z","comments":true,"path":"2019/12/01/Find them, Catch them/","link":"","permalink":"http://yoursite.com/2019/12/01/Find%20them,%20Catch%20them/","excerpt":"","text":"题目 - Find them, Catch themThe police office in Tadu City decides to say ends to the chaos, as launch actions to root up the TWO gangs in the city, Gang Dragon and Gang Snake. However, the police first needs to identify which gang a criminal belongs to. The present question is, given two criminals; do they belong to a same clan? You must give your judgment based on incomplete information. (Since the gangsters are always acting secretly.) Assume N (N &lt;= 10^5) criminals are currently in Tadu City, numbered from 1 to N. And of course, at least one of them belongs to Gang Dragon, and the same for Gang Snake. You will be given M (M &lt;= 10^5) messages in sequence, which are in the following two kinds: \\1. D [a] [b]where [a] and [b] are the numbers of two criminals, and they belong to different gangs. \\2. A [a] [b]where [a] and [b] are the numbers of two criminals. This requires you to decide whether a and b belong to a same gang. Input The first line of the input contains a single integer T (1 &lt;= T &lt;= 20), the number of test cases. Then T cases follow. Each test case begins with a line with two integers N and M, followed by M lines each containing one message as described above. Output For each message “A [a] [b]” in each case, your program should give the judgment based on the information got before. The answers might be one of “In the same gang.”, “In different gangs.” and “Not sure yet.” Sample Input 123456715 5A 1 2D 1 2A 1 2D 2 4A 1 4 Sample Output 123Not sure yet.In different gangs.In the same gang 题目大意:在一个城市里有两种不同的犯罪团伙。首先输入T表示有T组测试，然后输入N和M，表示有N个罪犯（编号从1到N）而且接下来有M个操作。操作分为两种： 1.D a b，表示编号为a和b的两个罪犯属于不同的犯罪团伙； 2.A a b，表示询问编号为a和b的两个罪犯是否是同一个犯罪团伙或者不确定。 对于每一个A操作，根据题意都要有相应的回答（输出）。 思路：一道标准的关系型并查集题。普通的并查集是给几个同类的元素，而关系型并查集是给不同类的元素，然后求各个元素之间的关系。对于这种题目,我们不仅需要开一个pre[]存父节点,还需要开一个r[]关系数组,来记录其和父亲的关系,r[]=0表示属于同一个帮派,r[]=1，表示不属于同一个帮派，初始化都为同一个帮派。一旦输入x和y不属于同一个帮派就将x和y连通同时更新r[]，一旦输入A，如果find（x）!=find（y）,说明还没输入它们的关系,所以不确定;如果find（x）==find(y） 由于r[]数组表示的是该节点和父节点的关系,两个节点又属于同一个节点,所以如果r[x]==r[y]则属于同一个帮派,否则不属于;处理方法:1、在利用find函数不断寻找根节点的过程中需要不断更新r[],举个例子:因为我们在利用find函数寻找根节点时有路径压缩,所以我们需要推导出子节点、父节点、和爷爷节点三者之间的关系:如果 子节点和父节点关系为r1，父节点和爷爷节点关系为r2，那么孙子节点和爷爷节点的关系为（r1+r2）%2;(两种情况所以对2去模)证明:我们可以列出所有的可能情况 （a, b） (b, c) (a, c) (r1+r2)%2 0 0 0 0 0 1 1 1 1 0 1 1 1 1 0 0PS:我个人一开始对为什么子父节点之间的关系会为同一个帮派感到困惑,因为题目中给出的都是不同帮派的,其实仔细一想并不是,我们在合并连通过程中存在着路径压缩,将孙子节点变为了儿子节点通过上面的关系式就有可能出现相同的情况了;2、在用join函数就行连通是也需要及时更新r[],我们还是通过推导得出关系式,假设我们f1为x1的根节点,f2为x2的根节点,我们现在要将f1合并到f2上去, 推导关系式为 r[f1]=(r[x1]+r[x2]+1)%2;证明:我们还是罗列出一些情况: 首先需要明确一点的,我们需要合并 x1和x2以为他们两个不是同一个帮派的,所以有x1和x2的关系为1（x1, f1） (x2, f2) (x1, x2) (f1,f2)_ 0 0 1 1 0 1 1 0 1 0 1 0 1 1 1 1 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;using namespace std;#define N 100010 int pre[N];int r[N];int n,m;void init() &#123; for (int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; pre[i]&#x3D;i; r[i]&#x3D;0; &#125; &#125;int find(int x) &#123; if(x&#x3D;&#x3D;pre[x]) return x; int tmp&#x3D;pre[x]; pre[x]&#x3D;find(pre[x]); r[x]&#x3D;(r[x]+r[tmp])%2; return pre[x]; &#125;void join(int x1,int x2) &#123; int f1&#x3D;find(x1); int f2&#x3D;find(x2); if(f1!&#x3D;f2) &#123; pre[f1]&#x3D;f2; r[f1]&#x3D;(r[x1]+r[x2]+1)%2; &#125; return ;&#125;int main() &#123; int t,i; char c; int a,b; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(); getchar(); for (i&#x3D;1;i&lt;&#x3D;m;i++) &#123; scanf(&quot;%c %d %d&quot;,&amp;c,&amp;a,&amp;b); getchar(); if(c&#x3D;&#x3D;&#39;D&#39;) &#123; join(a,b); &#125; else &#123; if(find(a)!&#x3D;find(b)) printf(&quot;Not sure yet.n&quot;); else &#123; if(r[a]&#x3D;&#x3D;r[b]) printf(&quot;In the same gang.n&quot;); else printf(&quot;In different gangs.\\n&quot;); &#125; &#125; &#125; &#125; return 0; &#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"带权并查集","slug":"带权并查集","permalink":"http://yoursite.com/tags/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"VJudge--The Suspects","slug":"The Suspects","date":"2019-11-30T16:00:00.000Z","updated":"2020-01-19T10:43:30.677Z","comments":true,"path":"2019/12/01/The Suspects/","link":"","permalink":"http://yoursite.com/2019/12/01/The%20Suspects/","excerpt":"","text":"题目 - The SuspectSevere acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).Once a member in a group is a suspect, all members in the group are suspects.However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects. Input The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.A case with n = 0 and m = 0 indicates the end of the input, and need not be processed. Output For each case, output the number of suspects in one line. Sample Input 12345678910100 42 1 25 10 13 11 12 142 0 12 99 2200 21 55 1 2 3 4 51 00 0 Sample Output 123411 题目大意:给定学生总数和学生分组，0号学生得了SARS 问有SARS的嫌疑的有多少人，和0同一组即为有嫌疑。 思路： AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;int a[30005] ,group[30005], num[30005];int findgroup(int x)&#x2F;&#x2F;查询每个学生的组长是谁。&#123; if(x&#x3D;&#x3D;group[x]) return x; else return findgroup(group[x]);&#125;void join(int x,int y)&#x2F;&#x2F;在同一组的学生需要把组长选定。&#123; int grox&#x3D;findgroup(x); int groy&#x3D;findgroup(y); if(grox!&#x3D;groy) &#123; group[grox]&#x3D;groy; num[groy]+&#x3D;num[grox];&#x2F;&#x2F;每一次合并，都需要吧集合中的元素个数加进去。 &#125; return ;&#125;int main()&#123; int n,m,k; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; if(n&#x3D;&#x3D;0&amp;&amp;m&#x3D;&#x3D;0) break; for(int i&#x3D;0; i&lt;n; i++) &#x2F;&#x2F;开个数组，给数组赋值，即自己自成一组并为组长。 &#123; group[i]&#x3D;i; num[i]&#x3D;1; &#125; while(m--)&#x2F;&#x2F;共有m个样例。 &#123; scanf(&quot;%d &quot;,&amp;k); for(int i&#x3D;0; i&lt;k; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i&#x3D;0; i&lt;k-1; i++)&#x2F;&#x2F;把在同一组的几个学生合并在一起。 join(a[i],a[i+1]);&#x2F;&#x2F;如果组长不同，便把组长选定。 &#125; int t&#x3D;findgroup(0);&#x2F;&#x2F;找到生病的0号学生的组长。 printf(&quot;%d\\n&quot;,num[t]); &#125;return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"VJudge--Wireless Network","slug":"Wireless Network","date":"2019-11-30T16:00:00.000Z","updated":"2020-01-19T10:43:20.430Z","comments":true,"path":"2019/12/01/Wireless Network/","link":"","permalink":"http://yoursite.com/2019/12/01/Wireless%20Network/","excerpt":"","text":"题目 - Wireless NetworkAn earthquake takes place in Southeast Asia. The ACM (Asia Cooperated Medical team) have set up a wireless network with the lap computers, but an unexpected aftershock attacked, all computers in the network were all broken. The computers are repaired one by one, and the network gradually began to work again. Because of the hardware restricts, each computer can only directly communicate with the computers that are not farther than d meters from it. But every computer can be regarded as the intermediary of the communication between two other computers, that is to say computer A and computer B can communicate if computer A and computer B can communicate directly or there is a computer C that can communicate with both A and B. In the process of repairing the network, workers can take two kinds of operations at every moment, repairing a computer, or testing if two computers can communicate. Your job is to answer all the testing operations. Input The first line contains two integers N and d (1 &lt;= N &lt;= 1001, 0 &lt;= d &lt;= 20000). Here N is the number of computers, which are numbered from 1 to N, and D is the maximum distance two computers can communicate directly. In the next N lines, each contains two integers xi, yi (0 &lt;= xi, yi &lt;= 10000), which is the coordinate of N computers. From the (N+1)-th line to the end of input, there are operations, which are carried out one by one. Each line contains an operation in one of following two formats:\\1. “O p” (1 &lt;= p &lt;= N), which means repairing computer p.\\2. “S p q” (1 &lt;= p, q &lt;= N), which means testing whether computer p and q can communicate. The input will not exceed 300000 lines. Output For each Testing operation, print “SUCCESS” if the two computers can communicate, or “FAIL” if not. Sample Input 12345678910114 10 10 20 30 4O 1O 2O 4S 1 4O 3S 1 4 Sample Output 12FAILSUCCESS 题目大意:给定学生总数和学生分组，0号学生得了SARS 问有SARS的嫌疑的有多少人，和0同一组即为有嫌疑。 思路： AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;int a[30005] ,group[30005], num[30005];int findgroup(int x)&#x2F;&#x2F;查询每个学生的组长是谁。&#123; if(x&#x3D;&#x3D;group[x]) return x; else return findgroup(group[x]);&#125;void join(int x,int y)&#x2F;&#x2F;在同一组的学生需要把组长选定。&#123; int grox&#x3D;findgroup(x); int groy&#x3D;findgroup(y); if(grox!&#x3D;groy) &#123; group[grox]&#x3D;groy; num[groy]+&#x3D;num[grox];&#x2F;&#x2F;每一次合并，都需要吧集合中的元素个数加进去。 &#125; return ;&#125;int main()&#123; int n,m,k; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; if(n&#x3D;&#x3D;0&amp;&amp;m&#x3D;&#x3D;0) break; for(int i&#x3D;0; i&lt;n; i++) &#x2F;&#x2F;开个数组，给数组赋值，即自己自成一组并为组长。 &#123; group[i]&#x3D;i; num[i]&#x3D;1; &#125; while(m--)&#x2F;&#x2F;共有m个样例。 &#123; scanf(&quot;%d &quot;,&amp;k); for(int i&#x3D;0; i&lt;k; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i&#x3D;0; i&lt;k-1; i++)&#x2F;&#x2F;把在同一组的几个学生合并在一起。 join(a[i],a[i+1]);&#x2F;&#x2F;如果组长不同，便把组长选定。 &#125; int t&#x3D;findgroup(0);&#x2F;&#x2F;找到生病的0号学生的组长。 printf(&quot;%d\\n&quot;,num[t]); &#125;return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"带权并查集","slug":"带权并查集","permalink":"http://yoursite.com/tags/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"VJudge--今年暑假不AC","slug":"今年暑假不AC","date":"2019-11-30T16:00:00.000Z","updated":"2020-01-19T10:42:38.924Z","comments":true,"path":"2019/12/01/今年暑假不AC/","link":"","permalink":"http://yoursite.com/2019/12/01/%E4%BB%8A%E5%B9%B4%E6%9A%91%E5%81%87%E4%B8%8DAC/","excerpt":"","text":"题目 - 今年暑假不AC“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目） Input 输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。 Output 对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。 Sample Input 1234567891011121314121 33 40 73 815 1915 2010 158 186 125 104 142 90 Sample Output 15 题目大意:中文题，意思很清楚了。 思路：要求看最多的节目，有三种思考方式:看最早开始时间（这个没用，不能保证两个节目不重合），用时最少的节目（这个也没用)，只有当上一个节目结束时才能进行下一个节目，所以下一个节目能否进行取决于上一个活动的最晚结束时间。因此，将每个时间的最晚结束时间先排序（由小到大），然后只要保证下一个活动的最早开始时间大于等于上一个活动的最晚结束时间就能顺利进行。由于要等所有的数据输入之后才能做出判断所以先用一个数组来存储最早开始时间和最晚结束时间（用结构体数组来存储)。 AC代码：1234567891011121314151617181920212223242526272829#include&lt;bits&#x2F;stdc++.h&gt; using namespace std;struct node&#123; int start,end;&#125;;bool cmp(const node&amp;a,const node&amp;b)&#123; return a.end&lt;b.end;&#125;int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n)&#123; node time[99]; int count &#x3D; 0; int endtime &#x3D; -1; for(int i&#x3D;0;i&lt;n;i++)&#123; cin&gt;&gt;time[i].start&gt;&gt;time[i].end; &#125; sort(time,time+n,cmp); for(int i&#x3D;0;i&lt;n;i++)&#123; if(time[i].start&gt;&#x3D;endtime) &#123; ++count; endtime &#x3D; time[i].end; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl;&#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"VJudge--食物链","slug":"食物链","date":"2019-11-30T16:00:00.000Z","updated":"2020-01-19T10:41:42.482Z","comments":true,"path":"2019/12/01/食物链/","link":"","permalink":"http://yoursite.com/2019/12/01/%E9%A3%9F%E7%89%A9%E9%93%BE/","excerpt":"","text":"题目 - 食物链动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 Input 第一行是两个整数N和K，以一个空格分隔。以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。若D=1，则表示X和Y是同类。若D=2，则表示X吃Y。 Output 只有一个整数，表示假话的数目。 Sample Input 12345678100 71 101 1 2 1 22 2 3 2 3 3 1 1 3 2 3 1 1 5 5 Sample Output 13 题目大意:( ﹁ ﹁ ) 中文题目读得懂.. 思路：确定关系的放在同一颗树里，另加一个r[]数组来记录每个结点和它的根节点的关系，r[]=0,代表同类;r[]=1,代表被父亲吃了；r[]=2，代表它吃了父亲。 满足其中一个为假话: 1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。 题目要判断假话的个数,输入的值为d,x,y。 首先可以判断x或者y是否大于N，如果大于，则假话数加一。 其次，通过find()函数找x，y的根结点判断是否相同。（相同说明有确定关系) 相同，则合并x，y所在的树，因为y被x吃所以将y树并在x树上，再更新y树对新的父结点的r[]值即r[fy]。 下面我们来分析一下r[fy]等于多少: fy-&gt;fx=fy-&gt;y+y-&gt;x+x-&gt;fx=3-r[y]+d-1+r[x] (因为d==1时，y-&gt;x=0;d==2时,y-&gt;x=1,所以y-&gt;x=1） 合并时: 1234567void unite(int x,int y,int d)&#123; int fx&#x3D;find(x); int fy&#x3D;find(y); p[fy]&#x3D;fx; r[fy]&#x3D;(r[x]-r[y]+3+(d-1))%3;&#125; 通过d的值来判断是否说谎。 如果d==1,r[x]!=r[y]，说谎数加一。 如果d==2,r[x]+1)%3!=r[y],说谎数加一。 查找: 12345678int find(int x)&#123; if(x&#x3D;&#x3D;p[x]) return x; int t&#x3D;p[x]; p[x]&#x3D;find(p[x]); r[x]&#x3D;(r[x]+r[t])%3; return p[x];&#125; 不相同，则两个结点建立关系。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;const int maxn &#x3D; 50000+10;int p[maxn]; int r[maxn];void set(int n) &#123; for(int x &#x3D; 1; x &lt;&#x3D; n; x++) &#123; p[x] &#x3D; x; r[x] &#x3D; 0; &#125;&#125; int find(int x) &#123; if(x &#x3D;&#x3D; p[x]) return x; int t &#x3D; p[x]; p[x] &#x3D; find(p[x]); r[x] &#x3D; (r[x]+r[t])%3; return p[x];&#125; void unite(int x, int y, int d)&#123; int fx &#x3D; find(x); int fy &#x3D; find(y); p[fy] &#x3D; fx; r[fy] &#x3D; (r[x]-r[y]+3+(d-1))%3; &#125; int main()&#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); set(n); int ans &#x3D; 0; int d, x, y; while(m--) &#123; scanf(&quot;%d%d%d&quot;, &amp;d, &amp;x, &amp;y); if(x &gt; n || y &gt; n || (d &#x3D;&#x3D; 2 &amp;&amp; x &#x3D;&#x3D; y)) ans++; else if(find(x) &#x3D;&#x3D; find(y)) &#123; if(d &#x3D;&#x3D; 1 &amp;&amp; r[x] !&#x3D; r[y]) ans++; if(d &#x3D;&#x3D; 2 &amp;&amp; (r[x]+1)%3 !&#x3D; r[y]) ans++; &#125; else unite(x, y, d); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"带权并查集","slug":"带权并查集","permalink":"http://yoursite.com/tags/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"POJ 1988 Cube Stacking","slug":"Cube Stacking","date":"2019-11-28T16:00:00.000Z","updated":"2019-12-01T12:08:35.800Z","comments":true,"path":"2019/11/29/Cube Stacking/","link":"","permalink":"http://yoursite.com/2019/11/29/Cube%20Stacking/","excerpt":"","text":"题目 - Cube Stacking Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations:moves and counts.* In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.* In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value. Write a program that can verify the results of the game. Input * Line 1: A single integer, P * Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X. Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself. Output Print the output from each of the count operations in the same order as the input file. Sample Input 12345676M 1 6C 1M 2 4M 2 6C 3C 4 Sample Output 123102 题意:有若干个方块，经p次操作后，在x方块下面的方块有多少个，M操作—&gt;将包含x方块的堆移到含y的堆上，C操作—&gt;输出x方块下方方块的数目。 思路： x方块下方方块数目=总数目-上方方块数目 如图所示 ![`T0X6L_@KNGWGV_IFP__4YG.png](https://i.loli.net/2019/12/01/5NJpSi28VfPBb4U.png) AC代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;int f[30010],cnt[30010],up[30010];int find(int x)&#123; int y; if(x!&#x3D;f[x]) &#123; y&#x3D;f[x]; f[x]&#x3D;find(y); up[x]+&#x3D;up[y]; &#125; return f[x];&#125;void Union(int x,int y)&#123; int px&#x3D;find(x); int py&#x3D;find(y); if(px&#x3D;&#x3D;py) return ; front[py]&#x3D;px; up[py]&#x3D;cnt[px]; cnt[px]+&#x3D;cnt[py];&#125;int main()&#123; int p,i,j,x,y; char a; cin&gt;&gt;p; for(i&#x3D;1;i&lt;&#x3D;30000;i++) &#123; f[i]&#x3D;i; cnt[i]&#x3D;1; up[i]&#x3D;0; &#125; while(p--) &#123; cin&gt;&gt;a; if(a&#x3D;&#x3D;&#39;M&#39;) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); Union(x,y); &#125; else &#123; scanf(&quot;%d&quot;,&amp;x); int px&#x3D;find(x); printf(&quot;%d\\n&quot;,cnt[px]-up[x]-1); &#125; &#125; return 0;&#125; 还有一种思路是把父亲放在下面，过程与上图类似，只不过是倒过来了。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;int f[30010],cnt[30010],dis[30010];int find(int x)&#123; int y; if(x!&#x3D;f[x]) &#123; y&#x3D;f[x]; f[x]&#x3D;find(f[x]); dis[x]+&#x3D;dis[y]; &#125; return f[x];&#125;void Union(int x,int y)&#123; int px&#x3D;find(x); int py&#x3D;find(y); if(px&#x3D;&#x3D;py) return ; f[px]&#x3D;py; dis[px]+&#x3D;cnt[py]; cnt[py]+&#x3D;cnt[px];&#125;int main()&#123; int p,i,j,x,y; char a; cin&gt;&gt;p; for(i&#x3D;1;i&lt;&#x3D;30000;i++) &#123; front[i]&#x3D;i; dis[i]&#x3D;0; cnt[i]&#x3D;1; &#125; while(p--) &#123; cin&gt;&gt;a; if(a&#x3D;&#x3D;&#39;M&#39;) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); Union(x,y); &#125; else &#123; scanf(&quot;%d&quot;,&amp;x); find(x); cout&lt;&lt;dis[x]&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"带权并查集","slug":"带权并查集","permalink":"http://yoursite.com/tags/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"并查集专题","slug":"ACM训练--并查集","date":"2019-11-26T16:00:00.000Z","updated":"2020-01-19T10:41:10.663Z","comments":true,"path":"2019/11/27/ACM训练--并查集/","link":"","permalink":"http://yoursite.com/2019/11/27/ACM%E8%AE%AD%E7%BB%83--%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"算法理解 ​ 并查集是一种树型的数据结构，用于处理一些不交集的合并和查询问题。联合-查找算法(union-find algorithm)定义了两个用于此数据结构的操作。 Union: 将两个子集合并成同一个集合，根据父节点的引用像根行进直到树根。 Find: 确定元素属于哪一个集合，方法就是不断的向上查找找到它的根节点，确定两个元素是否在同一个子集，将两棵树合并到一起，这通过将一颗树的根连接到另一棵树的根。 ​ 在并查集树中，每个集合的代表即是集合的根节点。 初始化 12for(int i&#x3D;1;i&lt;&#x3D;n;i++) pre[i]&#x3D;i;&#x2F;&#x2F;使每一个点的父结点都指向自己 查找 123456789101112131415&#x2F;&#x2F;递归int find(int x)&#123; if(pre[x]&#x3D;&#x3D;x) return x; return find(find(x));&#125;&#x2F;&#x2F;非递归int find(int x)&#123; int r&#x3D;x;&#x2F;&#x2F;将当前位置记录 while(pre(r)!&#x3D;r) &#x2F;&#x2F;如果不是根节点 r&#x3D;pre(r);&#x2F;&#x2F;继续向上查找，r的值更新为其父结点 return r;&#125; 但是这样写数据量大的时候会爆，下面来看路径压缩优化： 路径压缩优化 将某个根结点下的所有子结点都指向该根结点。 1234567891011121314151617int find(int x)&#123; int r&#x3D;x; while(pre[r]!&#x3D;r) &#123; r&#x3D;pre[r]; &#125; int i&#x3D;x;&#x2F;&#x2F;记录当前点 int j;&#x2F;&#x2F;记录i的上家 while(i!&#x3D;r)&#x2F;&#x2F;若当前点不是根结点 &#123; j&#x3D;pre[i];&#x2F;&#x2F;记录上家 pre[i]&#x3D;r;&#x2F;&#x2F;使当前点直接指向根节点 i&#x3D;j;&#x2F;&#x2F;当前点移动到上家 &#125; return r;&#125; 合并 123456void merge(int x,int y) &#x2F;&#x2F;合并集合 &#123; int t1&#x3D;find(x); &#x2F;&#x2F;找到x和y的根结点 int t2&#x3D;find(y); if(t1!&#x3D;t2) pre[t1]&#x3D;t2; &#x2F;&#x2F;所在集合不同，将其中一个作为另一个集合的子集(根结点一样)&#125; 例题：A - How Many TablesToday is Ignatius’ birthday. He invites a lot of friends. Now it’s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers. One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table. For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least. Input The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases. Output For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks. Sample Input 1234567825 31 22 34 55 12 5 Sample Output 1224 AC代码:12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;const int maxn &#x3D; 1050;int s[maxn];void init_set()&#123; for(int i&#x3D;1;i&lt;maxn;i++) s[i]&#x3D;i;&#125;int find_set(int x)&#123; return x&#x3D;&#x3D;s[x]?x:find_set(s[x]);&#125;void union_set(int x,int y)&#123; x&#x3D;find_set(x); y&#x3D;find_set(y); if(x!&#x3D;y) s[x]&#x3D;s[y];&#125;int main()&#123; int t,m,n,x,y; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;m; init_set(); for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123; cin&gt;&gt;x&gt;&gt;y; union_set(x,y); &#125; int ans&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; if(s[i]&#x3D;&#x3D;i) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; B - Ubiquitous ReligionsThere are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in. You know that there are n students in your university (0 &lt; n &lt;= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion. Input The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0. Output For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in. Sample Input 1234567891011121314151610 91 21 31 41 51 61 71 81 91 1010 42 34 54 85 80 0 Sample Output 12Case 1: 1Case 2: 7 Hint Huge input, scanf is recommended. 题目大意:有 个学生，编号 ，每个学生最多有 个宗教信仰，输入 组数据，每组数据包含 ，表示同学 和同学 有相同的信仰，求在 名学生中最多存在多少种不同的宗教信仰。 思路：与A题一样。 AC代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;const int maxn &#x3D; 50000+5;int s[maxn];int height[maxn];void init_set()&#123; for(int i &#x3D; 1;i&lt;&#x3D;maxn;i++)&#123; s[i]&#x3D;i; height[i]&#x3D;0; &#125;&#125;int find_set(int x)&#123; return x &#x3D;&#x3D; s[x] ? x:find_set(s[x]);&#125;void union_set(int x,int y)&#123; x &#x3D; find_set(x); y &#x3D; find_set(y); if(height[x] &#x3D;&#x3D; height[y])&#123; height[x] &#x3D; height[x] + 1; s[y] &#x3D; x; &#125;else&#123; if(height[x] &lt; height [y]) s[x] &#x3D; y; else s[y] &#x3D; x; &#125;&#125; int main()&#123; int t,n,m,x,y; int k&#x3D;1; while(cin &gt;&gt; n &gt;&gt;m &amp;&amp;m&amp;&amp;n)&#123; init_set(); for(int i &#x3D; 1;i&lt;&#x3D;m;i++)&#123; cin &gt;&gt;x&gt;&gt;y; union_set(x,y); &#125; int ans &#x3D; 0; for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; if(s[i] &#x3D;&#x3D; i) ans++; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;k++&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"VJudge--全排列","slug":"全排列","date":"2019-11-20T16:00:00.000Z","updated":"2020-01-19T10:42:23.840Z","comments":true,"path":"2019/11/21/全排列/","link":"","permalink":"http://yoursite.com/2019/11/21/%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"","text":"题目描述​ 排列与组合是常用的数学方法。先给一个正整数 ( 1 &lt; = n &lt; = 10 )例如n＝3，所有组合,并且按字典序输出：1 2 31 3 22 1 32 3 13 1 23 2 1 输入输入一个整数n( 1&lt;=n&lt;=10) 输出输出所有全排列 每个全排列一行，相邻两个数用空格隔开（最后一个数后面没有空格） 样例输入13 样例输出1234561 2 31 3 22 1 32 3 13 1 23 2 1 解析： ​ 1.首先我们考虑1号盒子，我们约定每到一个盒子面前都按数字递增的顺序摆放扑克牌。于是把1号扑克牌放到1号盒子中。​ 2.接着考虑2号盒子，现在我们手里剩下2号和3号扑克牌，于是我们可以把2号扑克牌放入2号盒子中。于是在3号盒子只剩一种可能性，我们继 续把3号扑克放入3号盒子。此时产生了一种排列——{1,2,3 ​ 3.接着我们收回3号盒子中的3号扑克牌，尝试一种新的可能，此时发现别无他选。于是选择回到2号盒子收回2号扑克。 ​ 4.在2号盒子中我们放入3号扑克，于是自然而然的在3号盒子中只能放入2号扑克。此时产生另一种排列——{1,3,2}； ​ 5.重复以上步骤就能得到数字{123}的全排列。 1、现在我们用C语言代码描述往每个小盒子中放入所有可能扑克牌的步骤： for(int i = 1; i &lt;= n; i++){ a[step] = i; //将i号扑克牌放入第step个盒子中 } 2、a是一个装入了所有小盒子的数组，变量step表示当前正处于第step号小盒子。i则表示扑克牌的序号。现在我们需要考虑另外一个问题，则如果一张扑克牌已经被放入别的盒子中，则不能再被放入当前盒子。 因此需要一个book数组标记哪些牌已经被使用。此时我们完善上述代码。 for(int i = 1; i &lt;= n; i++){ if(book[i] == 0){ a[step] = i; //将i号扑克牌放入第step个盒子中 book[i] = 1; // 置1表示第i号扑克牌不在手中 } } 现在对于step号盒子已经处理完，那么我们要考虑step+1号盒子。第step+1个的盒子的处理方式与第step个盒子的处理方式完全一样。因此，我们可以对上述操作做一个封装。 void dfs(int step) { //step表示当前要处理的盒子 for(int i = 1; i &lt;= n; i++) { if(book[i] == 0) { a[step] = i; //将i号扑克牌放入第step个盒子中 book[i] = 1; // 置1表示第i号扑克牌不在手中 } } } 于是我们重新回想文章开头阐述的放置扑克牌的思路： 我们在当前盒子放置完第i个扑克牌之后，便立即处理下一个盒子。于是： void dfs(int step) { //step表示当前要处理的盒子 for(int i = 1; i &lt;= n; i++) { if(book[i] == 0) { a[step] = i; //将i号扑克牌放入第step个盒子中 book[i] = 1; // 置1表示第i号扑克牌不在手中 dfs(step+1); //递归调用 book[i] = 0; // 非常重要，收回该盒子中的扑克牌才能进行下一次尝试。 } } } 需要注意到的是，我们需要收回每一次尝试的扑克牌i，才能进行下一次尝试。 现在需要考虑最后一个问题，那就是什么时候得到一个满足要求的排列，也就是考虑终止条件。这里很容易得到，当我们处理完成第n个盒子的时候，就已经得到一个符合要求的排列了。加上终止条件的代码如下： void dfs(int step){ //step表示当前要处理的盒子 if(step == n+1) { //输出排列 for(i = 1; i &lt;= n; i++) printf(“%d”, a[i]); printf(“\\n”); return; } for(int i = 1; i &lt;= n; i++) { if(book[i] == 0) { a[step] = i; //将i号扑克牌放入第step个盒子中 book[i] = 1; // 置1表示第i号扑克牌不在手中 dfs(step+1); //递归调用 book[i] = 0; // 非常重要，收回该盒子中的扑克牌才能进行下一次尝试。 } } } 现在深度优先搜索（DFS）的基本模型展现在我们眼前。 其核心在于，在当前步骤要把每一种可能性都尝试一遍（使用for循环），解决完当前步骤后进入下一步。而下一步的解决方式完全等同于当前步骤的解决方法。于是可以总结出DFS的基本模型： void dfs(int step){ 判断结束边界 尝试每一种可能 for(i = 1; i &lt;= n; i++) { 尝试下一步 dfs(step + 1); } return; }","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"深搜递归入门","slug":"深搜递归入门","permalink":"http://yoursite.com/tags/%E6%B7%B1%E6%90%9C%E9%80%92%E5%BD%92%E5%85%A5%E9%97%A8/"}]},{"title":"常见OJ错误","slug":"OJ错误","date":"2019-11-17T16:00:00.000Z","updated":"2019-11-29T15:46:53.548Z","comments":true,"path":"2019/11/18/OJ错误/","link":"","permalink":"http://yoursite.com/2019/11/18/OJ%E9%94%99%E8%AF%AF/","excerpt":"&emsp;&emsp;记录一下我在做题过程中WA的原因。","text":"&emsp;&emsp;记录一下我在做题过程中WA的原因。 ​ float换为double，如hdu2003。大家在做题的时候还是养成用double的习惯，因为一般由于用double而不是float导致超内存和超时而引起的问题很少出现。 ​ scanf()输入时注意用getchar（）存取换行符。 ​ 在输入数据时要考虑输入的数据是否满足条件，如hdu2007 。输入两个正整数x，y并不默认表示x&lt;y,在写代码时要判断一下是否x&lt;y，不然就WA掉了。而且要考虑到可能会出现的情况以及读清楚题意，如hdu2054。判断A和B是否相等，但题目并没有告诉A,B是什么类型，由于我默认认为它是整型，于是它又WA了。(我寻思这个题怎么这么简单…)。 ​ 一定要注意审题，如果题目没有说是整数就当double型以免WA掉例如hdu2039。 一些其他的错误: Presentation Error：注意一下最后一行有没有空格，在循环体中判断一下是不是最后一行。 Output Limit Exceeded：输入时用scanf()没有加!=EOF，陷入死循环(用cin可)。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"OJ错误","slug":"OJ错误","permalink":"http://yoursite.com/tags/OJ%E9%94%99%E8%AF%AF/"}]},{"title":"HDU2030--汉字统计","slug":"汉字统计","date":"2019-11-17T16:00:00.000Z","updated":"2019-11-29T15:48:40.233Z","comments":true,"path":"2019/11/18/汉字统计/","link":"","permalink":"http://yoursite.com/2019/11/18/%E6%B1%89%E5%AD%97%E7%BB%9F%E8%AE%A1/","excerpt":"","text":"汉字统计 Problem Description 统计给定文本文件中汉字的个数。 Input 输入文件首先包含一个整数n，表示测试实例的个数，然后是n段文本。 Output 对于每一段文本，输出其中的汉字的个数，每个测试实例的输出占一行。 [Hint:]从汉字机内码的特点考虑~ Sample Input 1232WaHaHa! WaHaHa! 今年过节不说话要说只说普通话WaHaHa! WaHaHa!马上就要期末考试了Are you ready? Sample Output 12149 Author lcy Source C语言程序设计练习（五） Recommend lcy | We have carefully selected several similar problems for you: 2031 2032 2026 2027 2024 思路：从汉字机内码的角度考虑，汉子机内码都是占两个字节且每个字节的第一个二进制位都是0,就是都为负数，除2就是汉字个数。 AC： 12345678910111213141516#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; getchar(); while(n--)&#123; char c; int m&#x3D;0; while((c&#x3D;getchar())!&#x3D;&#39;\\n&#39;) if(c&lt;0) m++; cout&lt;&lt;m&#x2F;2&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HDU第一阶段","slug":"HDU第一阶段","permalink":"http://yoursite.com/tags/HDU%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/"}]},{"title":"STL和基本数据结构","slug":"STL和基本数据结构","date":"2019-11-03T04:40:15.000Z","updated":"2019-11-29T15:45:55.614Z","comments":true,"path":"2019/11/03/STL和基本数据结构/","link":"","permalink":"http://yoursite.com/2019/11/03/STL%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"&emsp;&emsp;STL(Standard Template Library)是C++的标准模板库熟练掌握它们在很多题目中能极大地简化编程，需要完全掌握。","text":"&emsp;&emsp;STL(Standard Template Library)是C++的标准模板库熟练掌握它们在很多题目中能极大地简化编程，需要完全掌握。 &emsp;&emsp;STL包括容器(container)、迭代器(iterator)、空间配置器(allocator)、配接器(adapter)、算法(algorithm)、仿函数(functor)6个部分。 &emsp; 容器 &emsp; 1.顺序式容器 vector ：动态数组，从末尾能快速插入与删除，直接访问任何元素。 list ：双链表，从任何地方快速插入和删除。 deque ：双向队列，从前面或后面快速插入与删除，直接访问任何元素。 queue：队列，先进先出。 priority_queue：优先队列，最高优先级元素总是第一个出列。 stack：栈，后进先出。 &emsp; 2.关联式容器 set：集合，快速查找，不允许重复值。 map：一对多映射，基于关键字快速查找，不允许重复值。 multiset：快速查找，允许重复值。 multimap：一对多映射，基于关键字快速查找，允许重复值。 &emsp; vector hdu 4841 “圆桌问题” [https://vjudge.net/contest/337673#problem/A]: 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector &lt;int&gt; table; int m,n; while(cin&gt;&gt;n&gt;&gt;m)&#123; table.clear(); for(int i&#x3D;0;i&lt;2*n;i++) table.push_back(i); int pos &#x3D; 0; for(int i&#x3D;0;i&lt;n;i++)&#123; pos &#x3D; (pos+m-1)%table.size(); table.erase(table.begin()+pos); &#125; int j&#x3D;0; for(int i&#x3D;0;i&lt;2*n;i++)&#123; if(!(i%50)&amp;&amp;i) cout&lt;&lt;endl; if(j&lt;table.size()&amp;&amp;i&#x3D;&#x3D;table[j])&#123; j++; cout&lt;&lt;&quot;G&quot;; &#125; else cout&lt;&lt;&quot;B&quot;; &#125; cout&lt;&lt;endl&lt;&lt;endl; &#125; return 0;&#125; &emsp; stack hdu 1062 ”Text Reverse“ [https://vjudge.net/contest/337673#problem/B]: 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main()&#123; int n; char ch; scanf(&quot;%d&quot;,&amp;n); ch &#x3D; getchar(); while(n--)&#123; stack&lt;char&gt;s; while(true)&#123; ch &#x3D; getchar(); if(ch&#x3D;&#x3D;&#39;\\n&#39;||ch&#x3D;&#x3D;&#39; &#39;||ch&#x3D;&#x3D;EOF)&#123; while(!s.empty())&#123; printf(&quot;%c&quot;,s.top()); s.pop(); &#125; if(ch&#x3D;&#x3D;&#39;\\n&#39;||ch&#x3D;&#x3D;EOF) break; printf(&quot; &quot;); &#125; else s.push(ch); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; hdu 1237 “简单计算器” [https://vjudge.net/contest/337673#problem/C]: 思路：(太懒了8想写了..) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include&lt;stack&gt;using namespace std;int P(char c)&#123; if (c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39;) return 1; return 2;&#125;double Ans(double x, double y, char c)&#123; if (c &#x3D;&#x3D; &#39;+&#39;) return x + y; if (c &#x3D;&#x3D; &#39;-&#39;) return x - y; if (c &#x3D;&#x3D; &#39;*&#39;)return x*y; return x &#x2F; y;&#125;int main() &#123; int n; while (scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF) &#123; char c &#x3D; getchar(); if (c&#x3D;&#x3D;&#39;\\n&#39;&amp;&amp;n &#x3D;&#x3D; 0)break; stack&lt;char&gt; op; stack&lt;double&gt;num; num.push(n); while (true) &#123; scanf(&quot;%c %d&quot;, &amp;c, &amp;n); char k &#x3D; getchar(); while (!op.empty()&amp;&amp;P(c)&lt;&#x3D;P(op.top())) &#123; char t &#x3D; op.top(); op.pop(); double y &#x3D; num.top(); num.pop(); double x &#x3D; num.top(); num.pop(); double ans &#x3D; Ans(x, y, t); num.push(ans); &#125; op.push(c); num.push(n); if (k &#x3D;&#x3D; &#39;\\n&#39;)break; &#125; while (!op.empty()) &#123; char t &#x3D; op.top(); op.pop(); double y &#x3D; num.top(); num.pop(); double x &#x3D; num.top(); num.pop(); double ans &#x3D; Ans(x, y, t); num.push(ans); &#125; printf(&quot;%.2f\\n&quot;, num.top()); &#125; return 0;&#125; &emsp; Queue hdu 1702 ”ACboy needs your help again！“ [https://vjudge.net/contest/337673#problem/D]: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;stack&gt;using namespace std;int main()&#123; int t,temp,n; cin&gt;&gt;t; while(t--)&#123; string str1,str; queue&lt;int&gt;Q; stack&lt;int&gt;S; cin&gt;&gt;n&gt;&gt;str; for(int i&#x3D;0;i&lt;n;i++)&#123; if(str&#x3D;&#x3D;&quot;FIFO&quot;)&#123; cin&gt;&gt;str1; if(str1 &#x3D;&#x3D; &quot;IN&quot;)&#123; cin&gt;&gt;temp; Q.push(temp); &#125; if(str1 &#x3D;&#x3D; &quot;OUT&quot;)&#123; if(Q.empty()) cout&lt;&lt;&quot;None&quot;&lt;&lt;endl; else &#123; cout&lt;&lt;Q.front()&lt;&lt;endl; Q.pop(); &#125; &#125; &#125; else &#123; cin&gt;&gt;str1; if(str1 &#x3D;&#x3D; &quot;IN&quot;)&#123; cin&gt;&gt;temp; S.push(temp); &#125; if(str1 &#x3D;&#x3D; &quot;OUT&quot;)&#123; if(S.empty()) cout&lt;&lt;&quot;None&quot;&lt;&lt;endl; else &#123; cout&lt;&lt;S.top()&lt;&lt;endl; S.pop(); &#125; &#125; &#125;&#125;&#125; return 0;&#125; hdu 1873 ”看病要排队“ [https://vjudge.net/contest/337673#problem/E]: 注意队列中存放结构体的情况 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;struct node&#123; int n,id;&#125;st;bool operator &lt; (const node&amp;a,const node&amp;b)&#123; if(a.n&#x3D;&#x3D;b.n) return a.id&gt;b.id; else return a.n&lt;b.n;&#125;int main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123; priority_queue&lt;node&gt; q[4]; char s[10]; int a,b; int k&#x3D;1; for(int i&#x3D;0;i&lt;n;i++)&#123; scanf(&quot;%s %d&quot;,s,&amp;a); if(strcmp(s,&quot;IN&quot;)&#x3D;&#x3D;0)&#123; scanf(&quot;%d&quot;,&amp;b); st.n&#x3D;b; st.id&#x3D;k++; q[a].push(st); &#125; else &#123; if(!q[a].empty())&#123; st &#x3D; q[a].top(); q[a].pop(); printf(&quot;%d\\n&quot;,st.id); &#125; else printf(&quot;EMPTY\\n&quot;); &#125; &#125; &#125; return 0;&#125; &emsp; list hdu 1276 ”士兵队列训练问题“ [https://vjudge.net/contest/337673#problem/F]: 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;int main()&#123; int t,n; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; int k &#x3D; 2; list&lt;int&gt;mylist; list&lt;int&gt;::iterator it; for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; mylist.push_back(i); &#125; while(mylist.size()&gt;3)&#123; int num &#x3D; 1; for(it &#x3D; mylist.begin();it !&#x3D; mylist.end();)&#123; if(num++%k&#x3D;&#x3D;0) it &#x3D; mylist.erase(it); else it++; &#125; k&#x3D;&#x3D;2?k&#x3D;3:k&#x3D;2; &#125; for(it &#x3D;mylist.begin();it!&#x3D;mylist.end();it++)&#123; if(it!&#x3D;mylist.begin()) cout&lt;&lt;&quot; &quot;; cout&lt;&lt;*it; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; &emsp; set hdu 2094 “产生冠军” [https://vjudge.net/contest/337673#problem/G]: 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;string&gt;A,B; string s1,s2; int n; while(cin&gt;&gt;n&amp;&amp;n)&#123; for(int i&#x3D;0;i&lt;n;i++)&#123; cin&gt;&gt;s1&gt;&gt;s2; A.insert(s1); A.insert(s2); B.insert(s2); &#125; if(A.size()-B.size()&#x3D;&#x3D;1) &#123; cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; A.clear(); B.clear(); &#125; return 0;&#125; &emsp; map hdu 2648 “Shopping” [https://vjudge.net/contest/337673#problem/H]: 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n,m,p; map&lt;string,int&gt;shop; while(cin&gt;&gt;n)&#123; string s; for(int i&#x3D;0;i&lt;n;i++)&#123; cin&gt;&gt;s; &#125; cin&gt;&gt;m; while(m--)&#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; cin&gt;&gt;p&gt;&gt;s; shop[s]+&#x3D;p; &#125; int rank&#x3D; 1; map&lt;string,int&gt;::iterator it; for(it &#x3D; shop.begin();it!&#x3D;shop.end();it++)&#123; if(it-&gt;second&gt;shop[&quot;memory&quot;])&#123; rank++; &#125; &#125; cout&lt;&lt;rank&lt;&lt;endl; &#125; shop.clear();&#125; return 0;&#125; &emsp; next_permutation hdu 1027 \"Ignatius and the Princess II\" [https://vjudge.net/contest/337673#problem/I]: 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[1001]; int n,m; while(cin&gt;&gt;n&gt;&gt;m)&#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) a[i]&#x3D;i; int b &#x3D; 1; do&#123; if(m&#x3D;&#x3D;b) break; b++; &#125;while(next_permutation(a+1,a+1+n)); for(int i&#x3D;1;i&lt;n;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;a[n]&lt;&lt;endl; &#125; return 0;&#125; hdu 1716 “排列2” [https://vjudge.net/contest/337673#problem/J]: 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt; using namespace std; int main()&#123; int a[5],tag&#x3D;0; while(scanf(&quot;%d%d%d%d&quot;,&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3])) &#123; if(a[0]&#x3D;&#x3D;0 &amp;&amp; a[1]&#x3D;&#x3D;0 &amp;&amp; a[2]&#x3D;&#x3D;0 &amp;&amp; a[3]&#x3D;&#x3D;0) break; if(tag) printf(&quot;\\n&quot;); tag&#x3D;1; int flag&#x3D;1,tmp; do &#123; if(a[0]&#x3D;&#x3D;0) continue; if(flag) &#123; printf(&quot;%d%d%d%d&quot;,a[0],a[1],a[2],a[3]); flag&#x3D;0; &#125; else if(tmp&#x3D;&#x3D;a[0]) printf(&quot; %d%d%d%d&quot;,a[0],a[1],a[2],a[3]); else printf(&quot;\\n%d%d%d%d&quot;,a[0],a[1],a[2],a[3]); tmp&#x3D;a[0]; &#125;while(next_permutation(a,a+4)); printf(&quot;\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"数据结构-快慢指针","slug":"数据结构-快慢指针","date":"2019-10-02T16:00:00.000Z","updated":"2019-11-29T15:43:12.788Z","comments":true,"path":"2019/10/03/数据结构-快慢指针/","link":"","permalink":"http://yoursite.com/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/","excerpt":"&emsp;&emsp;快慢指针中的快慢指的是移动的步长，即每次向前移动速度的快慢,在使用快慢指针时可以让快指针每次沿链表向前移动2，慢指针每次向前一次。","text":"&emsp;&emsp;快慢指针中的快慢指的是移动的步长，即每次向前移动速度的快慢,在使用快慢指针时可以让快指针每次沿链表向前移动2，慢指针每次向前一次。 &emsp;快慢指针的应用 &emsp; (一)寻找链表中心 ​ 原理:快指针的移动速度是慢指针移动速度的两倍，因此当快指针到达表尾时慢指针到达中点，但要分奇偶情况讨论。 代码: 1234567891011121314151617181920212223while(fast &amp;&amp; slow)&#123;​ if(fast-&gt;next &#x3D;&#x3D; NULL)&#123;​ return slow-&gt;data;&#125;​ else if(fast-&gt;next !&#x3D; NULL&amp;&amp;fast-&gt;next-&gt;next &#x3D;&#x3D; NULL)&#123;​ return (slow-&gt;data + slow-&gt;next-&gt;data)&#x2F;2;&#125;​ else &#123;​ fast &#x3D; fast-&gt;next-&gt;next;​ slow &#x3D; slow-&gt;next;&#125;&#125; &emsp; (二)判断单链表中是否存在环 原理:类似于在操场上跑步，快指针的速度是慢指针移动速度的两倍，让两个指针都从链表头开始遍历，如果快指针最后指向空，则说明并没有环；如果最终快慢指针相等，则说明快指针追了上慢指针存在环。 代码： 123456789101112131415161718192021bool JudgeCircle(LNode *head)&#123;​ if(head&#x3D;&#x3D;NULL) return false;​ LNode *slow &#x3D; head;​ LNode *fast &#x3D; head;​ while(fast !&#x3D; NULL &amp;&amp; fast-&gt;next-&gt;next !&#x3D; NULL)&#123;​ slow &#x3D; slow-&gt;next;​ fast &#x3D; fast-&gt;next-&gt;next;​ if(slow &#x3D;&#x3D; fast) return true;&#125;​ return false;&#125; &emsp; (三)判断两个单链表是否相交 原理:首先利用快慢指针判断链表是否存在环。 (1)如果都不存在环，则如果两个单向链表有公共节点，也就是两个链表从某一节点开始，他们的p-&gt;next都指向同一个节点，每个节点只有一个p-&gt;next。因此从第一个公共节点开始，之后它们所有节点都是重合的。因此，首先两个链表各遍历一次，求出两个链表的长度L1、L2，然后可以得到它们的长度差L。然后现在长的链表上遍历L个节点，之后再同步遍历，于是在遍历中，第一个相同的节点就是第一个公共的节点。此时，若两个链表长度分别为M，N,则时间复杂度为O(M+N). (2)如果一个存在环，另外一个不存在环，则这两个链表是不可能相交的。 (3)如果利用快慢指针发现两个链表都存在环，则判断任意一个链表上快慢指针相遇的那个节点，在不在另外一个链表上，如果在，则相交，不在，则不相交。 第一种情况实现代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void Intersect(LinkList L1, LinkList L2) &#123; if (L1 &#x3D;&#x3D; NULL || L2 &#x3D;&#x3D; NULL) &#123; exit(); &#125; LinkList p &#x3D; L1; LinkList q &#x3D; L2; int length1 &#x3D; 0; int length2 &#x3D; 0; int len &#x3D; 0;while (p-&gt;next) &#123; length1 ++; p &#x3D; p-&gt;next;&#125;while (q-&gt;next) &#123; length2 ++; q &#x3D; q-&gt;next;&#125;cout&lt;&lt;p&lt;&lt;q;cout&lt;&lt;length1&lt;&lt;length2;if (p &#x3D;&#x3D; q) &#123; cout&lt;&lt;&quot;相交&quot;;if (length1 &gt; length2) &#123; len &#x3D; length1 - length2; p &#x3D; L2; q &#x3D; L1;&#125;else &#123; len &#x3D; length2 - length1; p &#x3D; L1; q &#x3D; L2;&#125;while (len) &#123; q &#x3D; q-&gt;next; len--;&#125;while (p !&#x3D; q) &#123; p &#x3D; p-&gt;next; q &#x3D; q-&gt;next;&#125;cout&lt;&lt;p-&gt;data;&#125;else &#123; cout&lt;&lt;&quot;不相交&quot;;&#125;&#125; &emsp;总结 上边的题是我在写LeetCode的时候发现挺有意思的就做了个汇总（当然还有一些其他的题目我想了好久，后边有时间再写），类似的题目还有寻找环的入口以及输出链表中倒数第K个节点。原理其实都差不多所以这两个题我就没有写上来。（参考来源于csdn,博客园,百度百科）","categories":[],"tags":[{"name":"快慢指针","slug":"快慢指针","permalink":"http://yoursite.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}]},{"title":"国庆前夕之学习历程","slug":"回文链表","date":"2019-09-28T16:00:00.000Z","updated":"2019-11-29T11:18:01.206Z","comments":true,"path":"2019/09/29/回文链表/","link":"","permalink":"http://yoursite.com/2019/09/29/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","excerpt":"&emsp; 刚学完数据结构的第二章，今天在写“回文链表”时遇到一点问题。","text":"&emsp; 刚学完数据结构的第二章，今天在写“回文链表”时遇到一点问题。 &emsp;&emsp;我的思路如下：用一个头指针head和一个尾指针tail，头指针向前移动head++，尾指针向后移动tail--,在这个过程中比较他们的值是否相等，如果不相等则返回false；如果相等则两个指针继续移动直至两个指针重合则返回true，说明它是回文链表，但是我编译运行之后并没有得到结果，我在想哪里出了问题，感觉思路没有问题，在看了代码之后我在想能不能用tail--逆向遍历链表呢，如果能逆向遍历那岂不是逆转链表特别容易了吗根本不用迭代和递归了，于是我去向别人求助查阅资料，得知链表中不能进行自增自减运算只能用p=p->next,我是感觉这两种一样，但为什么实际上不一样呢，然后我写了一个程序来验证。 &emsp;&emsp;程序测试结果表明，p++和p->next确实不一样，链表加1后不一定指向下一个节点，物理位置并没有连着。由于当时想到了线性表合并中两个指针的自增操作，把它带进了链表中，实际上顺序表是顺序存储结构，但链表并不是，所以p++并不等于p->next。 ​ 接着，说一下这几天写程序的感想。 ​ 《数据结构与算法》这本书非常重要，我们老师在给我们上课时讲到大二一定要过“编程关”，并建议我们每天花上一两个小时写程序。虽然我们是计算机科学与技术专业，编程能力的要求可能也没有软件工程要高，但是我觉得在学习中要以软件工程的标准来要求自己，有时间就去写写程序，量变达到质变，能力太重要啦。另外一点小小感悟，没事的时候就爱随便翻翻网站，今天逛了ccpc网络选拔赛和LeetCode的周赛排名榜，全国排名或者世界排名靠前的人基本上都是清华北大以及一些其他实力较强的985院校，像我所在的普通一本院校连报名的人都很少更别说获奖了，其实绝大多数人给我的感觉都不知道自己真正想要的是什么。可能差距从高考那一天就已经开始了，有时也会感悟，985院校真的会给你提供一个完全不一样的更高的平台。我也想好好努力，以考研为跳板去一个更高的平台，遇见更优秀的你和我！","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"回文链表","slug":"回文链表","permalink":"http://yoursite.com/tags/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"}]},{"title":"生活琐事","slug":"生活琐事","date":"2019-09-11T16:00:00.000Z","updated":"2019-11-29T11:15:57.436Z","comments":true,"path":"2019/09/12/生活琐事/","link":"","permalink":"http://yoursite.com/2019/09/12/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/","excerpt":"&emsp;生活碎片-1","text":"&emsp;生活碎片-1 &emsp;&emsp;最近喜欢上一句话“I love three things in the world,the sun,the moon and you，the sun for the day,the moon for the night,and you forever\",我什么时候会对一个人说这样的话呢。 &emsp;&emsp;心情复杂，烦恼又急切，焦虑又难过。明明是18岁最好的年纪，总是感觉达不到自己的期望值。这学期java，数据结构，python，四种语言混着用还是挺怕自己有些地方混淆，虽然这学期课也挺少的但是事情是真的多，C语言过编程关，java，python都得一起学以及12月份的英语六级。有时候我会想，我为什么大学不选个师范院校的英语专业或者就听我爸学医以后就安安逸逸的过自己一生得了，非得执着于计算机，可能我骨子里就是这样不安定，爱挑战一些有难度，新鲜的事物。每完成一道编程大题我就有一种做完一道奥数题的感觉，这种成就感和快乐让我很享受。还有一件最最最令人难过的事情，刚刚称了一下体重，真的胖了好多！！我不能再这样吃下去了！从明天开始，我要让这些不愉快都留在2019年，以一个更好的姿态迎接2020年！迎接19岁更好的自己！生活还是需要很多仪式感的。给我冲！！！（前面说完这些话，心情真的好多了）哦对了，明天中秋节我先祝自己中秋节快乐，而且我买了星光音乐节的票有赵雷还有隔壁老樊等等等这些民谣歌手，虽然我表面看起来是个喜欢技术的人但我骨子里应该算是个文艺的人。今天就说到这吧，晚安！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"The first article","slug":"第一篇博客","date":"2019-08-27T06:40:15.000Z","updated":"2019-11-29T11:14:51.826Z","comments":true,"path":"2019/08/27/第一篇博客/","link":"","permalink":"http://yoursite.com/2019/08/27/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"&emsp;&emsp;前几天在网上查资料的时候，看见别人的精美的博客页面，我寻思我可不可以也做一个自己的博客。说时迟，那时快，决定之后我立马就动手做了。 &emsp;&emsp;在CSDN，简书，博客园等的帮助下，我从在腾讯云上购买域名到注册github绑定域名，创建仓库，配置SSH key，修改主题，上传到github上等。这个过程中也遇到了一些问题（我也是算是小白中的小白了，这些东西都是第一次接触），多亏了互联网的强大，我才辛辛苦苦把我的个人网站搭建起来。虽然有一丝简陋，以后学习更多的新知识再改吧，拥有自己一小块地的感觉太好了（我可以为所欲为）。 &emsp;&emsp;这个博客以后主要是用来记录和总结我的学习以及生活，路漫漫其修远兮，吾将上下而求索！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"}]}]}